<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#

var measurements = new (string, string[], string[])[]
{
	// Measurement Type Definitions ------------------------------------------------
	
	("Acceleration", new string[] { "Length" }, new string[] { "Time", "Time" }),
	("AngularAcceleration", new string[] { "Angle" }, new string[] { "Time", "Time" }),
	("Angle", new string[] { "Angle" }, new string[] { }),
	("AngularSpeed", new string[] { "Angle" }, new string[] { "Time" }),
	("Area", new string[] { "Length", "Length" }, new string[] { }),
	("AreaDensity", new string[] { "Mass" }, new string[] { "Length", "Length" }),
	("Density", new string[] { "Mass" }, new string[] { "Length", "Length", "Length" }),
	("ElectricCharge", new string[] { "ElectricCharge" }, new string[] { }),
	("ElectricCurrent", new string[] { "ElectricCharge" }, new string[] { "Time" }),
	("Energy", new string[] { "Mass", "Length", "Length", }, new string[] { "Time", "Time", }),
	("Force", new string[] { "Mass", "Length" }, new string[] { "Time", "Time" }),
	("Length", new string[] { "Length" }, new string[] { }),
	("LinearDensity", new string[] { "Mass" }, new string[] { "Length" }),
	("LinearMass", new string[] { "Mass", "Length" }, new string[] { }),
	("LinearMassFlow", new string[] { "Mass", "Length" }, new string[] { "Time" }),
	("Mass", new string[] { "Mass" }, new string[] { }),
	("MassRate", new string[] { "Mass" }, new string[] { "Time" }),
	("Power", new string[] { "Mass", "Length", "Length", }, new string[] { "Time", "Time", "Time", }),
	("Pressure", new string[] { "Mass" }, new string[] { "Length", "Time", "Time", }),
	("Speed", new string[] { "Length" }, new string[] { "Time" }),
	("Tempurature", new string[] { "Tempurature" }, new string[] { }),
	("Time", new string[] { "Time" }, new string[] { }),
	("TimeArea", new string[] { "Time", "Time", }, new string[] { }),
	//("Torque", new string[] { "Mass", "Length", "Length" }, new string[] { "Time", "Time" }),
	("Volume", new string[] { "Length", "Length", "Length" }, new string[] { }),
	("VolumeRate", new string[] { "Length", "Length", "Length" }, new string[] { "Time" }),

	// Measurement Type Definitions --------------------------------------------------
};

var viewStrings = measurements.Select(x => string.Join("*", x.Item2) + (x.Item3.Length > 0 ? "/" + string.Join("/", x.Item3) : string.Empty)).ToArray();
var measurementsFormatted = measurements.Select(x => (x.Item1, x.Item2.Clone() as string[], x.Item3.Clone() as string[])).ToArray();
Array.ForEach(measurementsFormatted, x => { Array.Sort(x.Item2); Array.Sort(x.Item3); });
var keys = measurementsFormatted.Select(x => string.Join("*", x.Item2) + (x.Item3.Length > 0 ? "/" + string.Join("/", x.Item3) : string.Empty)).ToArray();
var baseUnitsToMeasurementMap = new Dictionary<string, string>();
for (int i = 0; i < keys.Length; i++) { baseUnitsToMeasurementMap.Add(keys[i], measurements[i].Item1); }
var measurementMappings = measurements.ToDictionary(x => x.Item1);
var multiplicationOperatorMappings = new Dictionary<string, List<(string, string)>>();
Array.ForEach(measurements, x => multiplicationOperatorMappings.Add(x.Item1, new List<(string, string)>()));
var divisionOperatorMappings = new Dictionary<string, List<(string, string)>>();
Array.ForEach(measurements, x => divisionOperatorMappings.Add(x.Item1, new List<(string, string)>()));

foreach (var a in measurements)
{
	foreach (var b in measurements)
	{
		{ // Multiplication
			List<string> numerators = (a.Item2.Concat(b.Item2)).ToList();
			List<string> denominators = (a.Item3.Concat(b.Item3)).ToList();
			foreach (string unit in numerators.ToList())
			{
				if (denominators.Contains(unit))
				{
					denominators.Remove(unit);
					numerators.Remove(unit);
				}
			}
			numerators.Sort();
			denominators.Sort();
			string key = string.Join("*", numerators) + (denominators.Count > 0 ? "/" + string.Join("/", denominators) : string.Empty);
			if (baseUnitsToMeasurementMap.TryGetValue(key, out string c))
			{
				multiplicationOperatorMappings[a.Item1].Add((b.Item1, c));
			}
		}
		{ // Division
			List<string> numerators = (a.Item2.Concat(b.Item3)).ToList();
			List<string> denominators = (a.Item3.Concat(b.Item2)).ToList();
			foreach (string unit in numerators.ToList())
			{
				if (denominators.Contains(unit))
				{
					denominators.Remove(unit);
					numerators.Remove(unit);
				}
			}
			numerators.Sort();
			denominators.Sort();
			string key = string.Join("*", numerators) + (denominators.Count > 0 ? "/" + string.Join("/", denominators) : string.Empty);
			if (baseUnitsToMeasurementMap.TryGetValue(key, out string c))
			{
				divisionOperatorMappings[a.Item1].Add((b.Item1, c));
			}
		}
	}
}

#>
//------------------------------------------------------------------------------
// <auto-generated>
//	  This code was generated from the "MeasurementTypes.tt" T4 Text Template.
// </auto-generated>
//------------------------------------------------------------------------------

// Measurement Definitions:
//
<# { int measurementIndex = 0; foreach (var measurement in measurements) { #>
//    <#= measurement.Item1 #>: <#= viewStrings[measurementIndex] #>
<# measurementIndex++; } } #>

#region Operators

// Operators:
//
<# { int measurementIndex = 0; foreach (var keyValue in multiplicationOperatorMappings) { #>
<# foreach (var @operator in keyValue.Value) { #>
//    <#= keyValue.Key #> * <#= @operator.Item1 #> = <#= @operator.Item2 #>
<# } measurementIndex++; } } #>
<# { int measurementIndex = 0; foreach (var keyValue in divisionOperatorMappings) { #>
<# foreach (var @operator in keyValue.Value) { #>
//    <#= keyValue.Key #> / <#= @operator.Item1 #> = <#= @operator.Item2 #>
<# } measurementIndex++; } } #>

#endregion

using System;
using static Towel.Statics;

namespace Towel.Measurements
{
<# { int measurementIndex = 0; foreach (var measurement in measurements) { #>
<# bool isBaseUnit = measurement.Item2.Length + measurement.Item3.Length == 1; #>
<# bool isDerivedUnit = !isBaseUnit; #>
<# var concatenatedBaseUnits = measurement.Item2.Concat(measurement.Item3); #>
	#region <#= measurement.Item1 #>

	internal static partial class ParsingFunctions
	{
		[Measurement.Parseable("<#= string.Join("*", measurement.Item2) #><#= measurement.Item3.Length > 0 ? "/" : string.Empty #><#= string.Join("/", measurement.Item3) #>")]
		public static object <#= measurement.Item1 #><T>(T value, object[] units)
		{
			if (units.Length != <#= concatenatedBaseUnits.Count() #>)
			{
				throw new Exception("Bug in Towel. Invalid parameters to <#= measurement.Item1 #> Factory.");
			}
<# { int baseUnitIndex = 0; foreach (var baseUnit in concatenatedBaseUnits) { #>
			if (!(units[<#= baseUnitIndex #>] is <#= baseUnit #>.Units))
			{
				throw new Exception("Bug in Towel. Invalid parameters to <#= measurement.Item1 #> Factory.");
			}
<# baseUnitIndex++; } } #>
			return new <#= measurement.Item1 #><T>(value
<# { int baseUnitIndex = 0; foreach (var baseUnit in concatenatedBaseUnits) { #>
				, (<#= baseUnit #>.Units)units[<#= baseUnitIndex #>]
<# baseUnitIndex++; } } #>
				);
		}
	}

	/// <summary><#= measurement.Item1 #> measurement with a value and the units.</summary>
	/// <typeparam name="T">The generic numeric type used to store the value of the measurement.</typeparam>
	public struct <#= measurement.Item1 #><T>
	{
<# if (isBaseUnit) { #>
		internal static Func<T, T>[][] Table = UnitConversionTable.Build<<#= measurement.Item1 #>.Units, T>();
<# } #>
		internal T _measurement;
<# { int baseUnitIndex = 0; foreach (var baseUnit in concatenatedBaseUnits) { #>
		internal <#= baseUnit #>.Units _<#= baseUnit #>Units<#= baseUnitIndex + 1 #>;
<# baseUnitIndex++; } } #>
<# //------------------------------------------------------------------------------------------- #>

		#region Statics

		/// <summary>Converts a <#= measurement.Item1 #> measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
<# { int baseUnitIndex = 0; foreach (var baseUnit in concatenatedBaseUnits) { #>
		/// <param name="from<#= baseUnit #>Units<#= baseUnitIndex + 1 #>">The current units of the measurement.</param>
<# baseUnitIndex++; } } #>
<# { int baseUnitIndex = 0; foreach (var baseUnit in concatenatedBaseUnits) { #>
		/// <param name="to<#= baseUnit #>Units<#= baseUnitIndex + 1 #>">The desired units of the measurement.</param>
<# baseUnitIndex++; } } #>
		/// <returns>The <#= measurement.Item1 #> measurement converted into the desired units.</returns>
		public static T Convert(T value
<# { int baseUnitIndex = 0; foreach (var baseUnit in concatenatedBaseUnits) { #>
			, <#= baseUnit #>.Units from<#= baseUnit #>Units<#= baseUnitIndex + 1 #>
<# baseUnitIndex++; } } #>
<# { int baseUnitIndex = 0; foreach (var baseUnit in concatenatedBaseUnits) { #>
			, <#= baseUnit #>.Units to<#= baseUnit #>Units<#= baseUnitIndex + 1 #>
<# baseUnitIndex++; } } #>
			)
		{
			<#= measurement.Item1 #><T> measurement = new <#= measurement.Item1 #><T>(value
<# { int baseUnitIndex = 0; foreach (var baseUnit in concatenatedBaseUnits) { #>
				, from<#= baseUnit #>Units<#= baseUnitIndex + 1 #>
<# baseUnitIndex++; } } #>
				);
			return measurement[
<# { int baseUnitIndex = 0; foreach (var baseUnit in concatenatedBaseUnits) { #>
				<#= baseUnitIndex == 0 ? string.Empty : "," #> to<#= baseUnit #>Units<#= baseUnitIndex + 1 #>
<# baseUnitIndex++; } } #>
				];
		}

		/// <summary>Converts a <#= measurement.Item1 #> measurement from units to another.</summary>
		/// <param name="value">The value to convert the units of.</param>
		/// <param name="from">The current units of the measurement.</param>
		/// <param name="to">The desired units of the measurement.</param>
		/// <returns>The <#= measurement.Item1 #> measurement converted into the desired units.</returns>
		public static T Convert(T value,
			MeasurementUnitsSyntaxTypes.<#= isDerivedUnit ? measurement.Item1 + "Base" : measurement.Item1 #>Units from,
			MeasurementUnitsSyntaxTypes.<#= isDerivedUnit ? measurement.Item1 + "Base" : measurement.Item1 #>Units to)
		{
			return Convert(value
<# { int baseUnitIndex = 0; foreach (var baseUnit in concatenatedBaseUnits) { #>
			, from._<#= baseUnit #>Units<#= baseUnitIndex + 1 #>
<# baseUnitIndex++; } } #>
<# { int baseUnitIndex = 0; foreach (var baseUnit in concatenatedBaseUnits) { #>
			, to._<#= baseUnit #>Units<#= baseUnitIndex + 1 #>
<# baseUnitIndex++; } } #>
			);
		}

		/// <summary>Parses a <#= measurement.Item1 #> measurement string.</summary>
		/// <param name="string">The string to be parsed.</param>
		/// <param name="value">The parsed value.</param>
		/// <param name="tryParse">The tryparse function for the generic type.</param>
		/// <returns>True if the parse was successful or false if not.</returns>
		public static bool TryParse(string @string, out <#= measurement.Item1 #><T> value, Func<string, (bool Success, T Value)> tryParse = null)
		{
			return Measurement.TryParse<T, <#= measurement.Item1 #><T>>(@string, out value, tryParse);
		}

		#endregion

<# //------------------------------------------------------------------------------------------- #>
		#region Constructors

		/// <summary>Constructs an <#= measurement.Item1 #> with the measurement value and units.</summary>
        /// <param name="measurement">The measurement value of the <#= measurement.Item1 #>.</param>
		/// <param name="units">The units of the <#= measurement.Item1 #>.</param>
		public <#= measurement.Item1 #>(T measurement, MeasurementUnitsSyntaxTypes.<#= isDerivedUnit ? measurement.Item1 + "Base" : measurement.Item1 #>Units units) : this(measurement
<# { int baseUnitIndex = 0; foreach (var baseUnit in concatenatedBaseUnits) { #>
			, units._<#= baseUnit #>Units<#= baseUnitIndex + 1 #>
<# baseUnitIndex++; } } #>
			) { }

<# if (isDerivedUnit && false) { #>
		/// <summary>Constructs an <#= measurement.Item1 #> with the measurement value and units.</summary>
        /// <param name="measurement">The measurement value of the <#= measurement.Item1 #>.</param>
        /// <param name="units">The units of the <#= measurement.Item1 #>.</param>
		public <#= measurement.Item1 #>(T measurement, <#= measurement.Item1 #>.Units units)
		{
			throw new NotImplementedException();
		}
<# } #>

		/// <summary>Constructs an <#= measurement.Item1 #> with the measurement value and units.</summary>
        /// <param name="measurement">The measurement value of the <#= measurement.Item1 #>.</param>
<# { int baseUnitIndex = 0; foreach (var baseUnit in concatenatedBaseUnits) { #>
		/// <param name="<#= baseUnit #>Units<#= baseUnitIndex + 1 #>">The units of the <#= measurement.Item1 #>.</param>
<# baseUnitIndex++; } } #>
		public <#= measurement.Item1 #>(T measurement
<# { int baseUnitIndex = 0; foreach (var baseUnit in concatenatedBaseUnits) { #>
			, <#= baseUnit #>.Units <#= baseUnit #>Units<#= baseUnitIndex + 1 #>
<# baseUnitIndex++; } } #>
			)
		{
			_measurement = measurement;
<# { int baseUnitIndex = 0; foreach (var baseUnit in concatenatedBaseUnits) { #>
			_<#= baseUnit #>Units<#= baseUnitIndex + 1 #> = <#= baseUnit #>Units<#= baseUnitIndex + 1 #>;
<# baseUnitIndex++; } } #>
		}

		#endregion

<# //------------------------------------------------------------------------------------------- #>
		#region Properties

<# { int baseUnitIndex = 0; foreach (var baseUnit in concatenatedBaseUnits) { #>
		/// <summary>The #<#= baseUnitIndex + 1 #> component of this measurements units.</summary>
        public <#= baseUnit #>.Units <#= baseUnit #>Units<#= baseUnitIndex + 1 #>
        {
            get { return _<#= baseUnit #>Units<#= baseUnitIndex + 1 #>; }
            set
            {
                if (value != _<#= baseUnit #>Units<#= baseUnitIndex + 1 #>)
                {
<# { int temp = 0; #>
                    _measurement = this[<#= string.Join(", ", concatenatedBaseUnits.Select(x => baseUnitIndex + 1 == ++temp ? "value" : "_" + x + "Units" + temp)) #>];
<# } #>
                    _<#= baseUnit #>Units<#= baseUnitIndex + 1 #> = value;
                }
            }
        }

<# baseUnitIndex++; } } #>
		/// <summary>Gets the measurement in the specified units.</summary>
        /// <param name="units">The units to get the measurement in.</param>
        /// <returns>The measurement value in the specified units.</returns>
		public T this[MeasurementUnitsSyntaxTypes.<#= isDerivedUnit ? measurement.Item1 + "Base" : measurement.Item1 #>Units units]
		{
<# { int temp = 0; #>
			get { return this[<#= string.Join(", ", concatenatedBaseUnits.Select(x => "units._" + x + "Units" + ++temp)) #>]; }
<# } #>
		}

		/// <summary>Gets the measurement in the specified units.</summary>
<# { int baseUnitIndex = 0; foreach (var baseUnit in concatenatedBaseUnits) { #>
		/// <param name="<#= baseUnit #>Units<#= baseUnitIndex + 1 #>">The #<#= baseUnitIndex + 1 #> component of this measurements units.</param>
<# baseUnitIndex++; } } #>
		/// <returns>The measurement value in the specified units.</returns>
<# { int temp = 0; #>
		public T this[<#= string.Join(", ", concatenatedBaseUnits.Select(x => x + ".Units" + " " + x + "Units" + ++temp)) #>]
<# } #>
        {
            get
            {
                T measurement = _measurement;
<# { int baseUnitIndex = 0; foreach (var numerator in measurement.Item2) { #>
                if (<#= numerator #>Units<#= baseUnitIndex + 1 #> != _<#= numerator #>Units<#= baseUnitIndex + 1 #>)
                {
					measurement = <#= numerator #><T>.Table[(int)_<#= numerator #>Units<#= baseUnitIndex + 1 #>][(int)<#= numerator #>Units<#= baseUnitIndex + 1 #>](measurement);
                    //if (<#= numerator #>Units<#= baseUnitIndex + 1 #> < _<#= numerator #>Units<#= baseUnitIndex + 1 #>)
                    //{
                    //    measurement = <#= numerator #><T>.Table[(int)_<#= numerator #>Units<#= baseUnitIndex + 1 #>][(int)<#= numerator #>Units<#= baseUnitIndex + 1 #>](measurement);
                    //}
                    //else
                    //{
                    //    measurement = <#= numerator #><T>.Table[(int)<#= numerator #>Units<#= baseUnitIndex + 1 #>][(int)_<#= numerator #>Units<#= baseUnitIndex + 1 #>](measurement);
                    //}
                }
<# baseUnitIndex++; } #>
<# foreach (var denominator in measurement.Item3) { #>
                if (<#= denominator #>Units<#= baseUnitIndex + 1 #> != _<#= denominator #>Units<#= baseUnitIndex + 1 #>)
                {
                    if (<#= denominator #>Units<#= baseUnitIndex + 1 #> > _<#= denominator #>Units<#= baseUnitIndex + 1 #>)
                    {
                        measurement = <#= denominator #><T>.Table[(int)_<#= denominator #>Units<#= baseUnitIndex + 1 #>][(int)<#= denominator #>Units<#= baseUnitIndex + 1 #>](measurement);
                    }
                    else
                    {
                        measurement = <#= denominator #><T>.Table[(int)<#= denominator #>Units<#= baseUnitIndex + 1 #>][(int)_<#= denominator #>Units<#= baseUnitIndex + 1 #>](measurement);
                    }
                }
<# baseUnitIndex++; } #>
<# } #>
                return measurement;
            }
        }

		#endregion
<# //------------------------------------------------------------------------------------------- #>

		#region Casting Operators

		/// <summary>Converts a ValueTuple to a <#= measurement.Item1 #> measurement.</summary>
		/// <param name="valueTuple">The ValueTuple to converted into a <#= measurement.Item1 #> measurement.</param>
		public static implicit operator <#= measurement.Item1 #><T>((T, MeasurementUnitsSyntaxTypes.<#= isDerivedUnit ? measurement.Item1 + "Base" : measurement.Item1 #>Units) valueTuple)
		{
			return new <#= measurement.Item1 #><T>(valueTuple.Item1, valueTuple.Item2);
		}

		#endregion

<# //------------------------------------------------------------------------------------------- #>
		#region Mathematics

		#region Bases

		internal static <#= measurement.Item1 #><T> MathBase(<#= measurement.Item1 #><T> a, T b, Func<T, T, T> func)
        {
            return new <#= measurement.Item1 #><T>(func(a._measurement, b)
<# { int baseUnitIndex = 0; foreach (var baseUnit in concatenatedBaseUnits) { #>
				, a._<#= baseUnit #>Units<#= baseUnitIndex + 1 #>
<# baseUnitIndex++; } } #>
			);
        }

        internal static <#= measurement.Item1 #><T> MathBase(<#= measurement.Item1 #><T> a, <#= measurement.Item1 #><T> b, Func<T, T, T> func)
        {
<# { int baseUnitIndex = 0; foreach (var baseUnit in concatenatedBaseUnits) { #>
			<#= baseUnit #>.Units <#= baseUnit #>Units<#= baseUnitIndex + 1 #> = a._<#= baseUnit #>Units<#= baseUnitIndex + 1 #> <= b._<#= baseUnit #>Units<#= baseUnitIndex + 1 #> ? a._<#= baseUnit #>Units<#= baseUnitIndex + 1 #> : b._<#= baseUnit #>Units<#= baseUnitIndex + 1 #>;
<# baseUnitIndex++; } } #>
<# { int temp = 0; #>
			T A = a[<#= string.Join(", ", concatenatedBaseUnits.Select(x => x + "Units" + ++temp)) #>];
<# } #>
<# { int temp = 0; #>
			T B = b[<#= string.Join(", ", concatenatedBaseUnits.Select(x => x + "Units" + ++temp)) #>];
<# } #>
            T C = func(A, B);
<# { int temp = 0; #>
			return new <#= measurement.Item1 #><T>(C, <#= string.Join(", ", concatenatedBaseUnits.Select(x => x + "Units" + ++temp)) #>);
<# } #>
        }

        internal static bool LogicBase(<#= measurement.Item1 #><T> a, <#= measurement.Item1 #><T> b, Func<T, T, bool> func)
        {
<# { int baseUnitIndex = 0; foreach (var baseUnit in concatenatedBaseUnits) { #>
			<#= baseUnit #>.Units <#= baseUnit #>Units<#= baseUnitIndex + 1 #> = a._<#= baseUnit #>Units<#= baseUnitIndex + 1 #> <= b._<#= baseUnit #>Units<#= baseUnitIndex + 1 #> ? a._<#= baseUnit #>Units<#= baseUnitIndex + 1 #> : b._<#= baseUnit #>Units<#= baseUnitIndex + 1 #>;
<# baseUnitIndex++; } } #>
<# { int temp = 0; #>
			T A = a[<#= string.Join(", ", concatenatedBaseUnits.Select(x => x + "Units" + ++temp)) #>];
<# } #>
<# { int temp = 0; #>
			T B = b[<#= string.Join(", ", concatenatedBaseUnits.Select(x => x + "Units" + ++temp)) #>];
<# } #>
            return func(A, B);
        }

		#endregion

		#region Add

        /// <summary>Adds two <#= measurement.Item1 #> measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static <#= measurement.Item1 #><T> Add(<#= measurement.Item1 #><T> a, <#= measurement.Item1 #><T> b)
        {
            return MathBase(a, b, Statics.Addition);
        }

        /// <summary>Adds two <#= measurement.Item1 #> measurements.</summary>
        /// <param name="a">The first operand of the addition.</param>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public static <#= measurement.Item1 #><T> operator +(<#= measurement.Item1 #><T> a, <#= measurement.Item1 #><T> b)
        {
            return Add(a, b);
        }

        /// <summary>Adds two <#= measurement.Item1 #> measurements.</summary>
        /// <param name="b">The second operand of the addition.</param>
        /// <returns>The result of the addition operation.</returns>
        public <#= measurement.Item1 #><T> Add(<#= measurement.Item1 #><T> b)
        {
            return this + b;
        }

        #endregion

        #region Subtract

        /// <summary>Subtracts two <#= measurement.Item1 #> measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static <#= measurement.Item1 #><T> Subtract(<#= measurement.Item1 #><T> a, <#= measurement.Item1 #><T> b)
        {
            return MathBase(a, b, Statics.Subtraction);
        }

        /// <summary>Subtracts two <#= measurement.Item1 #> measurements.</summary>
        /// <param name="a">The first operand of the subtraction.</param>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public static <#= measurement.Item1 #><T> operator -(<#= measurement.Item1 #><T> a, <#= measurement.Item1 #><T> b)
        {
            return Subtract(a, b);
        }

        /// <summary>Subtracts two <#= measurement.Item1 #> measurements.</summary>
        /// <param name="b">The second operand of the subtraction.</param>
        /// <returns>The result of the subtraction.</returns>
        public <#= measurement.Item1 #><T> Subtract(<#= measurement.Item1 #><T> b)
        {
            return this - b;
        }

        #endregion

        #region Multiply

        /// <summary>Multiplies an <#= measurement.Item1 #> by a scalar numeric value.</summary>
        /// <param name="a">The <#= measurement.Item1 #> measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static <#= measurement.Item1 #><T> Multiply(<#= measurement.Item1 #><T> a, T b)
        {
            return MathBase(a, b, Statics.Multiplication);
        }

        /// <summary>Multiplies an <#= measurement.Item1 #> by a scalar numeric value.</summary>
        /// <param name="a">The <#= measurement.Item1 #> measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static <#= measurement.Item1 #><T> Multiply(T b, <#= measurement.Item1 #><T> a)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an <#= measurement.Item1 #> by a scalar numeric value.</summary>
        /// <param name="a">The <#= measurement.Item1 #> measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static <#= measurement.Item1 #><T> operator *(<#= measurement.Item1 #><T> a, T b)
        {
            return Multiply(a, b);
        }

        /// <summary>Multiplies an <#= measurement.Item1 #> by a scalar numeric value.</summary>
        /// <param name="a">The <#= measurement.Item1 #> measurement to multiply.</param>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public static <#= measurement.Item1 #><T> operator *(T b, <#= measurement.Item1 #><T> a)
        {
            return Multiply(b, a);
        }

        /// <summary>Multiplies an <#= measurement.Item1 #> by a scalar numeric value.</summary>
        /// <param name="b">The scalar numeric value to multiply the measurement by.</param>
        /// <returns>The result of the multiplication.</returns>
        public <#= measurement.Item1 #><T> Add(T b)
        {
            return this * b;
        }
<# foreach ((string, string) @operator in multiplicationOperatorMappings[measurement.Item1]) { #>

		#region <#= measurement.Item1 #><T> * <#= @operator.Item1 #><T> = <#= @operator.Item2 #><T>

		/// <summary>Mulitplies <#= measurement.Item1 #> by <#= @operator.Item1 #> resulting in <#= @operator.Item2 #>.</summary>
		/// <param name="a">The <#= measurement.Item1 #> to be multiplied.</param>
		/// <param name="b">The <#= @operator.Item1 #> to multiply by.</param>
		/// <returns>The <#= @operator.Item2 #> result of the multiplication.</returns>
		public static <#= @operator.Item2 #><T> Multiply(<#= measurement.Item1 #><T> a, <#= @operator.Item1 #><T> b)
        {
<#

var aBaseUnits = measurement.Item2.Concat(measurement.Item3).ToList();
var aNumerators = measurement.Item2.ToList();
var aDenominators = measurement.Item3.ToList();

var bBaseUnits = measurementMappings[@operator.Item1].Item2.Concat(measurementMappings[@operator.Item1].Item3).ToList();
var bNumerators = measurementMappings[@operator.Item1].Item2.ToList();
var bDenominators = measurementMappings[@operator.Item1].Item3.ToList();

var cBaseUnits = measurementMappings[@operator.Item2].Item2.Concat(measurementMappings[@operator.Item2].Item3).ToList();

var unitCollisions = new List<(string, int, int)>();
var unitNoncollisions = new List<(string, bool, int)>();

foreach (var aNumerator in aNumerators.ToArray())
{
	if (bDenominators.Contains(aNumerator))
	{
		aNumerators.Remove(aNumerator);
		bDenominators.Remove(aNumerator);
		int aIndex = aBaseUnits.IndexOf(aNumerator);
		int bIndex = bBaseUnits.IndexOf(aNumerator);
		aBaseUnits[aIndex] = null;
		bBaseUnits[bIndex] = null;
		unitCollisions.Add((aNumerator, aIndex + 1, bIndex + 1));
	}
}
foreach (var aDenominator in aDenominators.ToArray())
{
	if (bNumerators.Contains(aDenominator))
	{
		aDenominators.Remove(aDenominator);
		bNumerators.Remove(aDenominator);
		int aIndex = aBaseUnits.IndexOf(aDenominator);
		int bIndex = bBaseUnits.IndexOf(aDenominator);
		aBaseUnits[aIndex] = null;
		bBaseUnits[bIndex] = null;
		unitCollisions.Add((aDenominator, aIndex + 1, bIndex + 1));
	}
}

for (int i = 0; i < aBaseUnits.Count; i++)
{
	var unit = aBaseUnits[i];
	if (unit is not null)
	{
		unitNoncollisions.Add((unit, true, i + 1));
	}
}

for (int i = 0; i < bBaseUnits.Count; i++)
{
	var unit = bBaseUnits[i];
	if (unit is not null)
	{
		unitNoncollisions.Add((unit, false, i + 1));
	}
}

var sortedUnitNoncollisions = new List<(string, bool, int)>();
foreach (var baseUnit in cBaseUnits)
{
	for (int i = 0; i < unitNoncollisions.Count; i++)
	{
		if (unitNoncollisions[i].Item1 == baseUnit)
		{
			sortedUnitNoncollisions.Add(unitNoncollisions[i]);
			unitNoncollisions[i] = default((string, bool, int));
		}
	}
}

string aIndexString = null;
{
	var aIndexers = new List<string>();
	var unitCollisionsCloneForA = unitCollisions.ToList();
	{ int temp = 1;
	foreach (var baseUnit in measurement.Item2.Concat(measurement.Item3).ToList())
	{
		int unitCollisionIndex = -1;
		for (int i = 0; i < unitCollisionsCloneForA.Count; i++)
		{
			var unitCollision = unitCollisionsCloneForA[i];
			if (unitCollision.Item1 == baseUnit)
			{
				unitCollisionIndex = i;
				break;
			}
		}
		
		if (unitCollisionIndex >= 0)
		{
			aIndexers.Add(baseUnit + "Units" + (unitCollisionIndex + 1));
			unitCollisionsCloneForA[unitCollisionIndex] = default((string, int, int));
		}
		else
		{
			aIndexers.Add("a._" + baseUnit + "Units" + temp);
		}
	temp++; } }
	aIndexString = string.Join(", ", aIndexers);
}

string bIndexString = null;
{
	var bIndexers = new List<string>();
	var unitCollisionsCloneForB = unitCollisions.ToList();
	{ int temp = 1;
	foreach (var baseUnit in measurementMappings[@operator.Item1].Item2.Concat(measurementMappings[@operator.Item1].Item3).ToList())
	{
		int unitCollisionIndex = -1;
		for (int i = 0; i < unitCollisionsCloneForB.Count; i++)
		{
			var unitCollision = unitCollisionsCloneForB[i];
			if (unitCollision.Item1 == baseUnit)
			{
				unitCollisionIndex = i;
				break;
			}
		}
		
		if (unitCollisionIndex >= 0)
		{
			bIndexers.Add(baseUnit + "Units" + (unitCollisionIndex + 1));
			unitCollisionsCloneForB[unitCollisionIndex] = default((string, int, int));
		}
		else
		{
			bIndexers.Add("b._" + baseUnit + "Units" + temp);
		}
	temp++; } }
	bIndexString = string.Join(", ", bIndexers);
}

#>
<# { int temp = 1; foreach (var unitCollision in unitCollisions) { #>
			<#= unitCollision.Item1 #>.Units <#= unitCollision.Item1 #>Units<#= temp #> = a._<#= unitCollision.Item1 #>Units<#= unitCollision.Item2 #> <= b._<#= unitCollision.Item1 #>Units<#= unitCollision.Item3 #> ? a._<#= unitCollision.Item1 #>Units<#= unitCollision.Item2 #> : b._<#= unitCollision.Item1 #>Units<#= unitCollision.Item3 #>;
<# temp++; } } #>

			T A = a[<#= aIndexString #>];
			T B = b[<#= bIndexString #>];
			T C = Statics.Multiplication(A, B);

			return new <#= @operator.Item2 #><T>(C
<# foreach (var unitNonCollision in sortedUnitNoncollisions) { #>
				, <#= (unitNonCollision.Item2 ? "a" : "b") + "._" + unitNonCollision.Item1 + "Units" + unitNonCollision.Item3 #>
<# } #>
				);
        }

		/// <summary>Mulitplies <#= measurement.Item1 #> by <#= @operator.Item1 #> resulting in <#= @operator.Item2 #>.</summary>
		/// <param name="a">The <#= measurement.Item1 #> to be multiplied.</param>
		/// <param name="b">The <#= @operator.Item1 #> to multiply by.</param>
		/// <returns>The <#= @operator.Item2 #> result of the multiplication.</returns>
		public static <#= @operator.Item2 #><T> operator *(<#= measurement.Item1 #><T> a, <#= @operator.Item1 #><T> b)
        {
			return Multiply(a, b);
        }

		/// <summary>Mulitplies <#= measurement.Item1 #> by <#= @operator.Item1 #> resulting in <#= @operator.Item2 #>.</summary>
		/// <param name="b">The <#= @operator.Item1 #> to multiply by.</param>
		/// <returns>The <#= @operator.Item2 #> result of the multiplication.</returns>
		public <#= @operator.Item2 #><T> Multiply(<#= @operator.Item1 #><T> b)
        {
			return this * b;
        }

		#endregion
<# } #>

        #endregion

        #region Divide

		/// <summary>Divides an <#= measurement.Item1 #> measurement by another <#= measurement.Item1 #> measurement resulting in a scalar numeric value.</summary>
        /// <param name="a">The first operand of the division operation.</param>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public static T Divide(<#= measurement.Item1 #><T> a, <#= measurement.Item1 #><T> b)
        {
<# { int baseUnitIndex = 0; foreach (var baseUnit in concatenatedBaseUnits) { #>
			<#= baseUnit #>.Units <#= baseUnit #>Units<#= baseUnitIndex + 1 #> = a._<#= baseUnit #>Units<#= baseUnitIndex + 1 #> <= b._<#= baseUnit #>Units<#= baseUnitIndex + 1 #> ? a._<#= baseUnit #>Units<#= baseUnitIndex + 1 #> : b._<#= baseUnit #>Units<#= baseUnitIndex + 1 #>;
<# baseUnitIndex++; } } #>
<# { int temp = 0; #>
			T A = a[<#= string.Join(", ", concatenatedBaseUnits.Select(x => x + "Units" + ++temp)) #>];
<# } #>
<# { int temp = 0; #>
			T B = b[<#= string.Join(", ", concatenatedBaseUnits.Select(x => x + "Units" + ++temp)) #>];
<# } #>
            return Statics.Division(A, B);
        }

        /// <summary>Divides this <#= measurement.Item1 #> measurement by a numaric scalar value.</summary>
        /// <param name="a">The <#= measurement.Item1 #> measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static <#= measurement.Item1 #><T> Divide(<#= measurement.Item1 #><T> a, T b)
        {
            return MathBase(a, b, Statics.Division);
        }

        /// <summary>Divides this <#= measurement.Item1 #> measurement by a numaric scalar value.</summary>
        /// <param name="a">The <#= measurement.Item1 #> measurement to divide.</param>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public static <#= measurement.Item1 #><T> operator /(<#= measurement.Item1 #><T> a, T b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides this <#= measurement.Item1 #> measurement by a numaric scalar value.</summary>
        /// <param name="b">The numeric scalar to divide by.</param>
        /// <returns>The result of the division.</returns>
        public <#= measurement.Item1 #><T> Divide(T b)
        {
            return this / b;
        }

        /// <summary>Divides an <#= measurement.Item1 #> measurement by another <#= measurement.Item1 #> measurement resulting in a scalar numeric value.</summary>
        /// <param name="a">The first operand of the division operation.</param>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public static T operator /(<#= measurement.Item1 #><T> a, <#= measurement.Item1 #><T> b)
        {
            return Divide(a, b);
        }

        /// <summary>Divides an <#= measurement.Item1 #> measurement by another <#= measurement.Item1 #> measurement resulting in a scalar numeric value.</summary>
        /// <param name="b">The second operand of the division operation.</param>
        /// <returns>The scalar numeric value result from the division.</returns>
        public T Divide(<#= measurement.Item1 #><T> b)
        {
            return this / b;
        }
<# foreach ((string, string) @operator in divisionOperatorMappings[measurement.Item1]) { #>

<# if (measurement.Item1 == @operator.Item1) { continue; } #>

		#region <#= measurement.Item1 #><T> / <#= @operator.Item1 #><T> = <#= @operator.Item2 #><T>

		/// <summary>Divides <#= measurement.Item1 #> by <#= @operator.Item1 #> resulting in <#= @operator.Item2 #>.</summary>
		/// <param name="a">The <#= measurement.Item1 #> to be divided.</param>
		/// <param name="b">The <#= @operator.Item1 #> to divide by.</param>
		/// <returns>The <#= @operator.Item2 #> result of the division.</returns>
		public static <#= @operator.Item2 #><T> Divide(<#= measurement.Item1 #><T> a, <#= @operator.Item1 #><T> b)
        {
<#

var aBaseUnits = measurement.Item2.Concat(measurement.Item3).ToList();
var aNumerators = measurement.Item2.ToList();
var aDenominators = measurement.Item3.ToList();

var bBaseUnits = measurementMappings[@operator.Item1].Item2.Concat(measurementMappings[@operator.Item1].Item3).ToList();
var bNumerators = measurementMappings[@operator.Item1].Item2.ToList();
var bDenominators = measurementMappings[@operator.Item1].Item3.ToList();

var cBaseUnits = measurementMappings[@operator.Item2].Item2.Concat(measurementMappings[@operator.Item2].Item3).ToList();

var unitCollisions = new List<(string, int, int)>();
var unitNoncollisions = new List<(string, bool, int)>();

foreach (var aNumerator in aNumerators.ToArray())
{
	if (bNumerators.Contains(aNumerator))
	{
		aNumerators.Remove(aNumerator);
		bNumerators.Remove(aNumerator);
		int aIndex = aBaseUnits.IndexOf(aNumerator);
		int bIndex = bBaseUnits.IndexOf(aNumerator);
		aBaseUnits[aIndex] = null;
		bBaseUnits[bIndex] = null;
		unitCollisions.Add((aNumerator, aIndex + 1, bIndex + 1));
	}
}
foreach (var aDenominator in aDenominators.ToArray())
{
	if (bDenominators.Contains(aDenominator))
	{
		aDenominators.Remove(aDenominator);
		bDenominators.Remove(aDenominator);
		int aIndex = aBaseUnits.IndexOf(aDenominator);
		int bIndex = bBaseUnits.IndexOf(aDenominator);
		aBaseUnits[aIndex] = null;
		bBaseUnits[bIndex] = null;
		unitCollisions.Add((aDenominator, aIndex + 1, bIndex + 1));
	}
}

for (int i = 0; i < aBaseUnits.Count; i++)
{
	var unit = aBaseUnits[i];
	if (unit is not null)
	{
		unitNoncollisions.Add((unit, true, i + 1));
	}
}

for (int i = 0; i < bBaseUnits.Count; i++)
{
	var unit = bBaseUnits[i];
	if (unit is not null)
	{
		unitNoncollisions.Add((unit, false, i + 1));
	}
}

var sortedUnitNoncollisions = new List<(string, bool, int)>();
foreach (var baseUnit in cBaseUnits)
{
	for (int i = 0; i < unitNoncollisions.Count; i++)
	{
		if (unitNoncollisions[i].Item1 == baseUnit)
		{
			sortedUnitNoncollisions.Add(unitNoncollisions[i]);
			unitNoncollisions[i] = default((string, bool, int));
		}
	}
}

string aIndexString = null;
{
	var aIndexers = new List<string>();
	var unitCollisionsCloneForA = unitCollisions.ToList();
	{ int temp = 1;
	foreach (var baseUnit in measurement.Item2.Concat(measurement.Item3).ToList())
	{
		int unitCollisionIndex = -1;
		for (int i = 0; i < unitCollisionsCloneForA.Count; i++)
		{
			var unitCollision = unitCollisionsCloneForA[i];
			if (unitCollision.Item1 == baseUnit)
			{
				unitCollisionIndex = i;
				break;
			}
		}
		
		if (unitCollisionIndex >= 0)
		{
			aIndexers.Add(baseUnit + "Units" + (unitCollisionIndex + 1));
			unitCollisionsCloneForA[unitCollisionIndex] = default((string, int, int));
		}
		else
		{
			aIndexers.Add("a._" + baseUnit + "Units" + temp);
		}
	temp++; } }
	aIndexString = string.Join(", ", aIndexers);
}

string bIndexString = null;
{
	var bIndexers = new List<string>();
	var unitCollisionsCloneForB = unitCollisions.ToList();
	{ int temp = 1;
	foreach (var baseUnit in measurementMappings[@operator.Item1].Item2.Concat(measurementMappings[@operator.Item1].Item3).ToList())
	{
		int unitCollisionIndex = -1;
		for (int i = 0; i < unitCollisionsCloneForB.Count; i++)
		{
			var unitCollision = unitCollisionsCloneForB[i];
			if (unitCollision.Item1 == baseUnit)
			{
				unitCollisionIndex = i;
				break;
			}
		}
		
		if (unitCollisionIndex >= 0)
		{
			bIndexers.Add(baseUnit + "Units" + (unitCollisionIndex + 1));
			unitCollisionsCloneForB[unitCollisionIndex] = default((string, int, int));
		}
		else
		{
			bIndexers.Add("b._" + baseUnit + "Units" + temp);
		}
	temp++; } }
	bIndexString = string.Join(", ", bIndexers);
}

#>
<# { int temp = 1; foreach (var unitCollision in unitCollisions) { #>
			<#= unitCollision.Item1 #>.Units <#= unitCollision.Item1 #>Units<#= temp #> = a._<#= unitCollision.Item1 #>Units<#= unitCollision.Item2 #> <= b._<#= unitCollision.Item1 #>Units<#= unitCollision.Item3 #> ? a._<#= unitCollision.Item1 #>Units<#= unitCollision.Item2 #> : b._<#= unitCollision.Item1 #>Units<#= unitCollision.Item3 #>;
<# temp++; } } #>

			T A = a[<#= aIndexString #>];
			T B = b[<#= bIndexString #>];
			T C = Statics.Division(A, B);

			return new <#= @operator.Item2 #><T>(C
<# foreach (var unitNonCollision in sortedUnitNoncollisions) { #>
				, <#= (unitNonCollision.Item2 ? "a" : "b") + "._" + unitNonCollision.Item1 + "Units" + unitNonCollision.Item3 #>
<# } #>
				);
        }

		/// <summary>Divides <#= measurement.Item1 #> by <#= @operator.Item1 #> resulting in <#= @operator.Item2 #>.</summary>
		/// <param name="a">The <#= measurement.Item1 #> to be divided.</param>
		/// <param name="b">The <#= @operator.Item1 #> to divide by.</param>
		/// <returns>The <#= @operator.Item2 #> result of the division.</returns>
		public static <#= @operator.Item2 #><T> operator /(<#= measurement.Item1 #><T> a, <#= @operator.Item1 #><T> b)
        {
			return Divide(a, b);
        }

		/// <summary>Divides <#= measurement.Item1 #> by <#= @operator.Item1 #> resulting in <#= @operator.Item2 #>.</summary>
		/// <param name="b">The <#= @operator.Item1 #> to divide by.</param>
		/// <returns>The <#= @operator.Item2 #> result of the division.</returns>
		public <#= @operator.Item2 #><T> Divide(<#= @operator.Item1 #><T> b)
        {
			return this / b;
        }

		#endregion
<# } #>

        #endregion

        #region LessThan

        /// <summary>Determines if an <#= measurement.Item1 #> measurement is less than another <#= measurement.Item1 #> measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool LessThan(<#= measurement.Item1 #><T> a, <#= measurement.Item1 #><T> b)
        {
            return LogicBase(a, b, Statics.LessThan);
        }

        /// <summary>Determines if an <#= measurement.Item1 #> measurement is less than another <#= measurement.Item1 #> measurement.</summary>
        /// <param name="a">The first operand of the less than operation.</param>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public static bool operator <(<#= measurement.Item1 #><T> a, <#= measurement.Item1 #><T> b)
        {
            return LessThan(a, b);
        }

        /// <summary>Determines if an <#= measurement.Item1 #> measurement is less than another <#= measurement.Item1 #> measurement.</summary>
        /// <param name="b">The second operand of the less than operation.</param>
        /// <returns>True if the first operand is less than the second operand. False if not.</returns>
        public bool LessThan(<#= measurement.Item1 #><T> b)
        {
            return this < b;
        }

        #endregion

        #region GreaterThan

        /// <summary>Determines if an <#= measurement.Item1 #> measurement is greater than another <#= measurement.Item1 #> measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool GreaterThan(<#= measurement.Item1 #><T> a, <#= measurement.Item1 #><T> b)
        {
            return LogicBase(a, b, Statics.GreaterThan);
        }

        /// <summary>Determines if an <#= measurement.Item1 #> measurement is greater than another <#= measurement.Item1 #> measurement.</summary>
        /// <param name="a">The first operand of the greater than operation.</param>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public static bool operator >(<#= measurement.Item1 #><T> a, <#= measurement.Item1 #><T> b)
        {
            return GreaterThan(a, b);
        }

        /// <summary>Determines if an <#= measurement.Item1 #> measurement is greater than another <#= measurement.Item1 #> measurement.</summary>
        /// <param name="b">The second operand of the greater than operation.</param>
        /// <returns>True if the first operand is greater than the second operand. False if not.</returns>
        public bool GreaterThan(<#= measurement.Item1 #><T> b)
        {
            return this > b;
        }

        #endregion

        #region LessThanOrEqual

        /// <summary>Determines if an <#= measurement.Item1 #> measurement is less than or equal to another <#= measurement.Item1 #> measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool LessThanOrEqual(<#= measurement.Item1 #><T> a, <#= measurement.Item1 #><T> b)
        {
            return LogicBase(a, b, Statics.LessThanOrEqual);
        }

        /// <summary>Determines if an <#= measurement.Item1 #> measurement is less than or equal to another <#= measurement.Item1 #> measurement.</summary>
        /// <param name="a">The first operand of the less than or equal to operation.</param>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public static bool operator <=(<#= measurement.Item1 #><T> a, <#= measurement.Item1 #><T> b)
        {
            return LessThanOrEqual(a, b);
        }

        /// <summary>Determines if an <#= measurement.Item1 #> measurement is less than or equal to another <#= measurement.Item1 #> measurement.</summary>
        /// <param name="b">The second operand of the less than or equal to operation.</param>
        /// <returns>True if the first operand is less than or equal to the second operand. False if not.</returns>
        public bool LessThanOrEqual(<#= measurement.Item1 #><T> b)
        {
            return this <= b;
        }

        #endregion

        #region GreaterThanOrEqual

        /// <summary>Determines if an <#= measurement.Item1 #> measurement is greater than or equal to another <#= measurement.Item1 #> measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool GreaterThanOrEqual(<#= measurement.Item1 #><T> a, <#= measurement.Item1 #><T> b)
        {
            return LogicBase(a, b, Statics.GreaterThanOrEqual);
        }

        /// <summary>Determines if an <#= measurement.Item1 #> measurement is greater than or equal to another <#= measurement.Item1 #> measurement.</summary>
        /// <param name="a">The first operand of the greater than or equal to operation.</param>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public static bool operator >=(<#= measurement.Item1 #><T> a, <#= measurement.Item1 #><T> b)
        {
            return GreaterThanOrEqual(a, b);
        }

        /// <summary>Determines if an <#= measurement.Item1 #> measurement is greater than or equal to another <#= measurement.Item1 #> measurement.</summary>
        /// <param name="b">The second operand of the greater than or equal to operation.</param>
        /// <returns>True if the first operand is greater than or equal to the second operand. False if not.</returns>
        public bool GreaterThanOrEqual(<#= measurement.Item1 #><T> b)
        {
            return this >= b;
        }

        #endregion

        #region Equal

        /// <summary>Determines if an <#= measurement.Item1 #> measurement is equal to another <#= measurement.Item1 #> measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool Equal(<#= measurement.Item1 #><T> a, <#= measurement.Item1 #><T> b)
        {
            return LogicBase(a, b, Statics.Equate);
        }

        /// <summary>Determines if an <#= measurement.Item1 #> measurement is equal to another <#= measurement.Item1 #> measurement.</summary>
        /// <param name="a">The first operand of the equal to operation.</param>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public static bool operator ==(<#= measurement.Item1 #><T> a, <#= measurement.Item1 #><T> b)
        {
            return Equal(a, b);
        }

        /// <summary>Determines if an <#= measurement.Item1 #> measurement is equal to another <#= measurement.Item1 #> measurement.</summary>
        /// <param name="b">The second operand of the equal to operation.</param>
        /// <returns>True if the first operand is equal to the second operand. False if not.</returns>
        public bool Equal(<#= measurement.Item1 #><T> b)
        {
            return this == b;
        }

        #endregion

        #region NotEqual

        /// <summary>Determines if an <#= measurement.Item1 #> measurement is not equal to another <#= measurement.Item1 #> measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool NotEqual(<#= measurement.Item1 #><T> a, <#= measurement.Item1 #><T> b)
        {
            return LogicBase(a, b, Statics.Inequate);
        }

        /// <summary>Determines if an <#= measurement.Item1 #> measurement is not equal to another <#= measurement.Item1 #> measurement.</summary>
        /// <param name="a">The first operand of the not equal to operation.</param>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public static bool operator !=(<#= measurement.Item1 #><T> a, <#= measurement.Item1 #><T> b)
        {
            return NotEqual(a, b);
        }

        /// <summary>Determines if an <#= measurement.Item1 #> measurement is not equal to another <#= measurement.Item1 #> measurement.</summary>
        /// <param name="b">The second operand of the not equal to operation.</param>
        /// <returns>True if the first operand is not equal to the second operand. False if not.</returns>
        public bool NotEqual(<#= measurement.Item1 #><T> b)
        {
            return this != b;
        }

        #endregion

		#endregion

<# //------------------------------------------------------------------------------------------- #>
		#region Overrides

		/// <summary>Base Equals override that performs a type and value equality check.</summary>
        /// <param name="obj">The object to check for equality with.</param>
        /// <returns>True if the types and values equal. False if not.</returns>
		public override bool Equals(object obj)
        {
            if (obj is <#= measurement.Item1 #><T>)
            {
                return this == (<#= measurement.Item1 #><T>)obj;
            }
            return false;
        }

		/// <summary>Converts the <#= measurement.Item1 #> measurement to a string represenation.</summary>
        /// <returns>The string representation of the measurement.</returns>
		public override string ToString()
        {
            return _measurement + " " +
<# { int temp = 0; #>
				<#= string.Join(" + \"*\" + ", measurement.Item2.Select(x => "_" + x + "Units" + ++temp)) #>
<# if (measurement.Item3.Length > 0) { #>
				+ "/" +
<# } #>
				<#= string.Join(" + \"/\" + ", measurement.Item3.Select(x => "_" + x + "Units" + ++temp)) #>
<# } #>
				;
        }

		/// <summary>Base hashing function for <#= measurement.Item1 #> measurements.</summary>
        /// <returns>Computed hash code for this instance.</returns>
        public override int GetHashCode()
        {
            return
                _measurement.GetHashCode()
<# { int baseUnitIndex = 0; foreach (var baseUnit in concatenatedBaseUnits) { #>
				^ _<#= baseUnit #>Units<#= baseUnitIndex + 1 #>.GetHashCode()
<# baseUnitIndex++; } } #>
				;
        }

		#endregion
	}

	#endregion

<# measurementIndex++; } } #>

<# //------------------------------------------------------------------------------------------- #>
	#region MeasurementUnitsSyntaxTypes

	#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

	public static class MeasurementUnitsSyntaxTypes
	{
<# { int measurementIndex = 0; foreach (var measurement in measurements) { #>
<# bool isBaseUnit = measurement.Item2.Length + measurement.Item3.Length == 1; #>
<# bool isDerivedUnit = !isBaseUnit; #>
<# var concatenatedBaseUnits = measurement.Item2.Concat(measurement.Item3); #>
		public struct <#= isDerivedUnit ? measurement.Item1 + "Base" : measurement.Item1 #>Units : Measurement.IUnits<<#= isDerivedUnit ? measurement.Item1 + "Base" : measurement.Item1 #>Units>
		{
<# { int baseUnitIndex = 0; foreach (var baseUnit in concatenatedBaseUnits) { #>
			public <#= baseUnit #>.Units _<#= baseUnit #>Units<#= baseUnitIndex + 1 #>;
<# baseUnitIndex++; } } #>

<# { int baseUnitIndex = 0; #>
			public <#= isDerivedUnit ? measurement.Item1 + "Base" : measurement.Item1 #>Units(<#= string.Join(", ", concatenatedBaseUnits.Select(x => x + ".Units " + x + "Units" + (++baseUnitIndex))) #>)
<# } #>
			{
<# { int baseUnitIndex = 0; foreach (var baseUnit in concatenatedBaseUnits) { #>
				_<#= baseUnit #>Units<#= baseUnitIndex + 1 #> = <#= baseUnit #>Units<#= baseUnitIndex + 1 #>;
<# baseUnitIndex++; } } #>
			}

			public T Convert<T>(T value,
				<#= isDerivedUnit ? measurement.Item1 + "Base" : measurement.Item1 #>Units from,
				<#= isDerivedUnit ? measurement.Item1 + "Base" : measurement.Item1 #>Units to)
			{
				return <#= measurement.Item1 #><T>.Convert(value, from, to);
			}
<# foreach ((string, string) @operator in multiplicationOperatorMappings[measurement.Item1]) { #>
<# var isBDerivedUnit = measurementMappings[@operator.Item1].Item2.Length + measurementMappings[@operator.Item1].Item3.Length > 1; #>
<# var isCDerivedUnit = measurementMappings[@operator.Item2].Item2.Length + measurementMappings[@operator.Item2].Item3.Length > 1; #>		
<#

var aBaseUnits = measurement.Item2.Concat(measurement.Item3).ToList();
var aNumerators = measurement.Item2.ToList();
var aDenominators = measurement.Item3.ToList();

var bBaseUnits = measurementMappings[@operator.Item1].Item2.Concat(measurementMappings[@operator.Item1].Item3).ToList();
var bNumerators = measurementMappings[@operator.Item1].Item2.ToList();
var bDenominators = measurementMappings[@operator.Item1].Item3.ToList();

var cBaseUnits = measurementMappings[@operator.Item2].Item2.Concat(measurementMappings[@operator.Item2].Item3).ToList();

var unitCollisions = new List<(string, int, int)>();
var unitNoncollisions = new List<(string, bool, int)>();

foreach (var aNumerator in aNumerators.ToArray())
{
	if (bDenominators.Contains(aNumerator))
	{
		aNumerators.Remove(aNumerator);
		bDenominators.Remove(aNumerator);
		int aIndex = aBaseUnits.IndexOf(aNumerator);
		int bIndex = bBaseUnits.IndexOf(aNumerator);
		aBaseUnits[aIndex] = null;
		bBaseUnits[bIndex] = null;
		unitCollisions.Add((aNumerator, aIndex + 1, bIndex + 1));
	}
}
foreach (var aDenominator in aDenominators.ToArray())
{
	if (bNumerators.Contains(aDenominator))
	{
		aDenominators.Remove(aDenominator);
		bNumerators.Remove(aDenominator);
		int aIndex = aBaseUnits.IndexOf(aDenominator);
		int bIndex = bBaseUnits.IndexOf(aDenominator);
		aBaseUnits[aIndex] = null;
		bBaseUnits[bIndex] = null;
		unitCollisions.Add((aDenominator, aIndex + 1, bIndex + 1));
	}
}

for (int i = 0; i < aBaseUnits.Count; i++)
{
	var unit = aBaseUnits[i];
	if (unit is not null)
	{
		unitNoncollisions.Add((unit, true, i + 1));
	}
}

for (int i = 0; i < bBaseUnits.Count; i++)
{
	var unit = bBaseUnits[i];
	if (unit is not null)
	{
		unitNoncollisions.Add((unit, false, i + 1));
	}
}

var sortedUnitNoncollisions = new List<(string, bool, int)>();
foreach (var baseUnit in cBaseUnits)
{
	for (int i = 0; i < unitNoncollisions.Count; i++)
	{
		if (unitNoncollisions[i].Item1 == baseUnit)
		{
			sortedUnitNoncollisions.Add(unitNoncollisions[i]);
			unitNoncollisions[i] = default((string, bool, int));
		}
	}
}

if (unitCollisions.Count > 0)
{
	continue;
}

#>
			public static <#= isCDerivedUnit ? @operator.Item2 + "Base" : @operator.Item2 #>Units operator *(<#= isDerivedUnit ? measurement.Item1 + "Base" : measurement.Item1 #>Units a, <#= isBDerivedUnit ? @operator.Item1 + "Base" : @operator.Item1 #>Units b)
			{
				return new <#= isCDerivedUnit ? @operator.Item2 + "Base" : @operator.Item2 #>Units(<#= string.Join(", ", sortedUnitNoncollisions.Select(x => (x.Item2 ? "a" : "b") + "._" + x.Item1 + "Units" + x.Item3)) #>);
			}
<# } #>
<# //------------------------------------------------------------------ #>
<# foreach ((string, string) @operator in divisionOperatorMappings[measurement.Item1]) { #>
<# var isBDerivedUnit = measurementMappings[@operator.Item1].Item2.Length + measurementMappings[@operator.Item1].Item3.Length > 1; #>
<# var isCDerivedUnit = measurementMappings[@operator.Item2].Item2.Length + measurementMappings[@operator.Item2].Item3.Length > 1; #>		
<#

var aBaseUnits = measurement.Item2.Concat(measurement.Item3).ToList();
var aNumerators = measurement.Item2.ToList();
var aDenominators = measurement.Item3.ToList();

var bBaseUnits = measurementMappings[@operator.Item1].Item2.Concat(measurementMappings[@operator.Item1].Item3).ToList();
var bNumerators = measurementMappings[@operator.Item1].Item2.ToList();
var bDenominators = measurementMappings[@operator.Item1].Item3.ToList();

var cBaseUnits = measurementMappings[@operator.Item2].Item2.Concat(measurementMappings[@operator.Item2].Item3).ToList();

var unitCollisions = new List<(string, int, int)>();
var unitNoncollisions = new List<(string, bool, int)>();

foreach (var aNumerator in aNumerators.ToArray())
{
	if (bNumerators.Contains(aNumerator))
	{
		aNumerators.Remove(aNumerator);
		bNumerators.Remove(aNumerator);
		int aIndex = aBaseUnits.IndexOf(aNumerator);
		int bIndex = bBaseUnits.IndexOf(aNumerator);
		aBaseUnits[aIndex] = null;
		bBaseUnits[bIndex] = null;
		unitCollisions.Add((aNumerator, aIndex + 1, bIndex + 1));
	}
}
foreach (var aDenominator in aDenominators.ToArray())
{
	if (bDenominators.Contains(aDenominator))
	{
		aDenominators.Remove(aDenominator);
		bDenominators.Remove(aDenominator);
		int aIndex = aBaseUnits.IndexOf(aDenominator);
		int bIndex = bBaseUnits.IndexOf(aDenominator);
		aBaseUnits[aIndex] = null;
		bBaseUnits[bIndex] = null;
		unitCollisions.Add((aDenominator, aIndex + 1, bIndex + 1));
	}
}

for (int i = 0; i < aBaseUnits.Count; i++)
{
	var unit = aBaseUnits[i];
	if (unit is not null)
	{
		unitNoncollisions.Add((unit, true, i + 1));
	}
}

for (int i = 0; i < bBaseUnits.Count; i++)
{
	var unit = bBaseUnits[i];
	if (unit is not null)
	{
		unitNoncollisions.Add((unit, false, i + 1));
	}
}

var sortedUnitNoncollisions = new List<(string, bool, int)>();
foreach (var baseUnit in cBaseUnits)
{
	for (int i = 0; i < unitNoncollisions.Count; i++)
	{
		if (unitNoncollisions[i].Item1 == baseUnit)
		{
			sortedUnitNoncollisions.Add(unitNoncollisions[i]);
			unitNoncollisions[i] = default((string, bool, int));
		}
	}
}

if (unitCollisions.Count > 0)
{
	continue;
}

#>
			public static <#= isCDerivedUnit ? @operator.Item2 + "Base" : @operator.Item2 #>Units operator /(<#= isDerivedUnit ? measurement.Item1 + "Base" : measurement.Item1 #>Units a, <#= isBDerivedUnit ? @operator.Item1 + "Base" : @operator.Item1 #>Units b)
			{
				return new <#= isCDerivedUnit ? @operator.Item2 + "Base" : @operator.Item2 #>Units(<#= string.Join(", ", sortedUnitNoncollisions.Select(x => (x.Item2 ? "a" : "b") + "._" + x.Item1 + "Units" + x.Item3)) #>);
			}
<# } #>
		}

<# if (isDerivedUnit && false) { #>
		public struct <#= measurement.Item1 #>Units
		{
			public <#= measurement.Item1 #>.Units _<#= measurement.Item1 #>Units;
		}

<# } #>
<# measurementIndex++; } } #>
	}

	#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member

	#endregion
}