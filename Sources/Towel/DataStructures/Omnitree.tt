<#@ template debug="false" hostspecific="false" language="C#" #><#@ output extension=".cs" #><#@ assembly name="System.Numerics" #><#@ import namespace="System.Numerics" #><# int[] dimensionsToGenerate = new int[] { 1, 2, 3, 4, 5, 6, 7 }; #>//------------------------------------------------------------------------------
// <auto-generated>
//	  This code was generated from the "Omnitree.tt" T4 Text Template.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using Towel.Mathematics;
using System.Numerics;

namespace Towel.DataStructures
{
    #region Notes

    // Visualizations--------------------------------------------------
    //
    // 1 Dimensional:
    //
    //  -1D |-----------|-----------| +1D
    //
    //       <--- 0 ---> <--- 1 --->
    //
    // 2 Dimensional:
    //       _____________________
    //      |          |          |  +2D
    //      |          |          |   ^
    //      |     2    |     3    |   |
    //      |          |          |   |
    //      |----------|----------|   |
    //      |          |          |   |
    //      |          |          |   |
    //      |     0    |     1    |   |
    //      |          |          |   v
    //      |__________|__________|  -2D
    //
    //       -1D <-----------> +1D 
    //
    // 3 Dimensional:
    //
    //            +3D     _____________________
    //           7       /         /          /|
    //          /       /    6    /     7    / |
    //         /       /---------/----------/  |
    //        /       /    2    /     3    /|  |
    //       L       /_________/__________/ |  |
    //    -3D       |          |          | | /|          +2D
    //              |          |          | |/ |           ^
    //              |     2    |     3    | /  |           |
    //              |          |          |/|  | <-- 5     |
    //              |----------|----------| |  |           |
    //              |          |          | |  /           |
    //              |          |          | | /            |
    //              |     0    |     1    | |/             |
    //              |          |          | /              v
    //              |__________|__________|/              -2D
    //	         
    //                   ^
    //                   |
    //                   4 (behind 0)
    //
    //               -1D <-----------> +1D
    //
    // Functionality------------------------------------------------------
    //
    // Load Variables:
    //
    // There are 2 load variables: 1) items-per-leaf and 2) tree-depth. These are
    // recomputed after additions and removals.
    //
    //   1) items-per-leaf
    //
    //      DESCRIPTION: indicates how many items can be placed in a leaf before a
    //      tree expansion should occur
    //
    //      EXAMPLE: if the current items-per-leaf value is 7 but we just added 8 
    //      items to a leaf, that leaf must become a branch and its contents must
    //      be divided up into new leaves of the new branch
    //
    //   2) tree-depth
    //
    //      DESCRIPTION: indicates the currently allowed tree depth preventing
    //      tree expansion when it would actually harm the structures algorithms
    //
    //      EXAMPLE: a leaf's count went over the items-per-leaf, but the tree is
    //      already incredibly imbalanced because we are at the currently allowed
    //      tree-depth, thus expansion does not occur; this often happens when the
    //      tree contains multiples of the same value

    #endregion

	/// <summary>Contains the necessary type definitions for the various omnitree types.</summary>
    public static partial class Omnitree
    {
        #region Spacial Types (Bound, Vector, Bounds) And Location/Bounding Functions
<# foreach (int i in dimensionsToGenerate) { #>
        #region <#= i #> Dimensional

        public struct Vector<A1<# for (int j = 2; j <= i; j++) { #>, A<#= j #><# } #>>
        {<# for (int j = 1; j <= i; j++) { #>
            internal A<#= j #> _axis<#= j #>;<# } #>
<# for (int j = 1; j <= i; j++) { #>
            /// <summary>The value along axis <#= j #>.</summary>
            public A<#= j #> Axis<#= j #> { get { return this._axis<#= j #>; } }<# } #>

            /// <summary>Returns a vector with defaulted values.</summary>
            public static Vector<A1<# for (int j = 2; j <= i; j++) { #>, A<#= j #><# } #>> Default
            {
                get { return new Vector<A1<# for (int j = 2; j <= i; j++) { #>, A<#= j #><# } #>>(default(A1)<# for (int j = 2; j <= i; j++) { #>, default(A<#= j #>)<# } #>); }
            }

            /// <summary>A location along each axis.</summary><# for (int j = 1; j <= i; j++) { #>
            /// <param name="axis<#= j #>">The location along axis <#= j #>.</param><# } #>
            public Vector(A1 axis1<# for (int j = 2; j <= i; j++) { #>, A<#= j #> axis<#= j #><# } #>)
            {<# for (int j = 1; j <= i; j++) { #>
                this._axis<#= j #> = axis<#= j #>;<# } #>
            }
        }

        public struct Bounds<A1<# for (int j = 2; j <= i; j++) { #>, A<#= j #><# } #>>
        {<# for (int j = 1; j <= i; j++) { #>
            Bound<A<#= j #>> _min<#= j #>, _max<#= j #>;<# } #>
<# for (int j = 1; j <= i; j++) { #>
            public Bound<A<#= j #>> Min<#= j #> { get { return this._min<#= j #>; } }
            public Bound<A<#= j #>> Max<#= j #> { get { return this._max<#= j #>; } }<# } #>

            /// <summary>Extends infinitely along each axis.</summary>
            public static Bounds<A1<# for (int j = 2; j <= i; j++) { #>, A<#= j #><# } #>> None
            {
                get
                {
                    return new Bounds<A1<# for (int j = 2; j <= i; j++) { #>, A<#= j #><# } #>>(
                        Bound<A1>.None, Bound<A1>.None<# for (int j = 2; j <= i; j++) { #>,
                        Bound<A<#= j #>>.None, Bound<A<#= j #>>.None<# } #>);
                }
            }
            
            /// <summary>A set of values denoting a range (or lack of range) along each axis.</summary>
            public Bounds(
                Bound<A1> min1, Bound<A1> max1<# for (int j = 2; j <= i; j++) { #>,
                Bound<A<#= j #>> min<#= j #>, Bound<A<#= j #>> max<#= j #><# } #>)
            {<# for (int j = 1; j <= i; j++) { #>
                this._min<#= j #> = min<#= j #>;
                this._max<#= j #> = max<#= j #>;<# } #>
            }
        }

        public delegate void Location<T, A1<# for (int j = 2; j <= i; j++) { #>, A<#= j #><# } #>>(T element, out A1 axis1<# for (int j = 2; j <= i; j++) { #>, out A<#= j #> axis<#= j #><# } #>);

        public delegate void GetBounds<T, A1<# for (int j = 2; j <= i; j++) { #>, A<#= j #><# } #>>(T element, out Bound<A1> min1, out Bound<A1> max1<# for (int j = 2; j <= i; j++) { #>, out Bound<A<#= j #>> min<#= j #>, out Bound<A<#= j #>> max<#= j #><# } #>);

		public delegate void GetBoundings<T, A1<# for (int j = 2; j <= i; j++) { #>, A<#= j #><# } #>>(T element, out A1 min1, out A1 max1<# for (int j = 2; j <= i; j++) { #>, out A<#= j #> min<#= j #>, out A<#= j #> max<#= j #><# } #>);

		internal static GetBounds<T, A1<# for (int j = 2; j <= i; j++) { #>, A<#= j #><# } #>> ConvertToGetBounds<T, A1<# for (int j = 2; j <= i; j++) { #>, A<#= j #><# } #>>(GetBoundings<T, A1<# for (int j = 2; j <= i; j++) { #>, A<#= j #><# } #>> getBoundings)
		{
			return (T item<# for (int j = 1; j <= i; j++) { #>,
				out Bound<A<#= j #>> minBound<#= j #>, out Bound<A<#= j #>> maxBound<#= j #><# } #>) =>
				{<# for (int j = 1; j <= i; j++) { #>
					A<#= j #> min<#= j #>; A<#= j #> max<#= j #>;<# } #>
					getBoundings(item<# for (int j = 1; j <= i; j++) { #>,
						out min<#= j #>, out max<#= j #><# } #>);

					<# for (int j = 1; j <= i; j++) { #>
					minBound<#= j #> = min<#= j #>; maxBound<#= j #> = max<#= j #>;<# } #>
				};
		}

        #endregion
<# } #>
        #endregion
    }
    
    #region OmnitreePoints
    
    // NOTE: the ND version can be found int "Omnitree_ND.cs"<# foreach (int i in dimensionsToGenerate) { #>
<# // ------------------------------------------------------------------------------------------------------------------------------ 
 // PARAMETER/ARGUMENT CHAINS
      string chain_AxisX = "Axis1"; for (int j = 2; j <= i; j++) { chain_AxisX += ", Axis" + j; } 
      string chain_axisX = "axis1"; for (int j = 2; j <= i; j++) { chain_axisX += ", axis" + j; } 
      string chain_AxisX_axisX = "Axis1 axis1"; for (int j = 2; j <= i; j++) { chain_AxisX_axisX += ", Axis" + j + " axis" + j; }
      string chain_AxisX_minX_AxisX_maxX = "Axis1 min1, Axis1 max1"; for (int j = 2; j <= i; j++) { chain_AxisX_minX_AxisX_maxX += ", Axis" + j + " min" + j + ", Axis" + j + " max" + j; }
      string chain_BoundAxisX_minX_BoundAxisX_maxX = "Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1"; for (int j = 2; j <= i; j++) { chain_BoundAxisX_minX_BoundAxisX_maxX += ", Omnitree.Bound<Axis" + j + "> min" + j + ", Omnitree.Bound<Axis" + j + "> max" + j; }
      string chain_BoundAxisX_axisX = "Omnitree.Bound<Axis1> axis1"; for (int j = 2; j <= i; j++) { chain_BoundAxisX_axisX += ", Omnitree.Bound<Axis" + j + "> axis" + j; }
      string chain_minX_maxX = "min1, max1"; for (int j = 2; j <= i; j++) { chain_minX_maxX += ", min" + j + ", max" + j; }
      string chain_axisX_axisX = "axis1, axis1"; for (int j = 2; j <= i; j++) { chain_axisX_axisX += ", axis" + j + ", axis" + j; }
      string child_index_type; if (i <= 30) { child_index_type = "int"; } else if (i <= 60) { child_index_type = "long"; } else { child_index_type = "BigInteger"; }
 // DOCUMENTATION
      string documentation_AxisX_axisX = string.Empty; for (int j = 1; j <= i; j++) { documentation_AxisX_axisX += "\n\t\t/// <param name=\"axis" + j + "\">The coordinate along the " + j + "D axis.</param>"; } documentation_AxisX_axisX = documentation_AxisX_axisX.Trim();
      string documentation_AxisX_minX_AxisX_maxX = string.Empty; for (int j = 1; j <= i; j++) { documentation_AxisX_minX_AxisX_maxX += "\n\t\t/// <param name=\"min" + j + "\">The minimum coordinate of the space along the " + j + " axis.</param>\n\t\t/// <param name=\"max" + j + "\">The maximum coordinate of the space along the " + j + " axis.</param>"; } documentation_AxisX_minX_AxisX_maxX = documentation_AxisX_minX_AxisX_maxX.Trim();
      string documentation_axisX = string.Empty; for (int j = 1; j <= i; j++) { documentation_axisX += "\n\t\t/// <param name=\"axis" + j + "\">The axis of the removal along the  " + j + "D axis.</param>"; } documentation_axisX = documentation_axisX.Trim();
 // ------------------------------------------------------------------------------------------------------------------------------ #>
    #region <#= i #> Dimensional

    public interface IOmnitreePoints<T, <#= chain_AxisX #>> : IDataStructure<T>,
            DataStructure.ICountable,
            DataStructure.IAddable<T>,
            DataStructure.IClearable,
            DataStructure.IRemovable<T>,
            DataStructure.IEquating<T>
    {
        #region Properties

        /// <summary>Steps through the values at a given location.</summary>
        <#= documentation_AxisX_axisX #>
        /// <returns>A Stepper of the items at the given coordinates.</returns>
        Stepper<T> this[<#= chain_AxisX_axisX #>] { get; }
        /// <summary>The number of dimensions in this tree.</summary>
        int Dimensions { get; }

        #endregion

        #region Methods

        /// <summary>Counts the number of items in a sub space.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpace(<#= chain_BoundAxisX_minX_BoundAxisX_maxX #>);

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        void Update();
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        void Update(<#= chain_BoundAxisX_minX_BoundAxisX_maxX #>);

        /// <summary>Removes all the items in a given space.</summary>
        <#= documentation_AxisX_axisX #>
        void Remove(<#= chain_AxisX_axisX #>);
        /// <summary>Removes all the items in a given space.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        void Remove(<#= chain_BoundAxisX_minX_BoundAxisX_maxX #>);
        /// <summary>Removes all the items in a given space where equality is met.</summary>
        <#= documentation_AxisX_axisX #>
        /// <param name="where">The equality constraint of the removal.</param>
        void Remove(<#= chain_AxisX_axisX #>, Predicate<T> where);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        /// <param name="where">The predicate constraint of the removal.</param>
        void Remove(<#= chain_BoundAxisX_minX_BoundAxisX_maxX #>, Predicate<T> where);

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        void Stepper(Step<T> step, <#= chain_BoundAxisX_minX_BoundAxisX_maxX #>);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        StepStatus Stepper(StepBreak<T> step, <#= chain_BoundAxisX_minX_BoundAxisX_maxX #>);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        <#= documentation_AxisX_axisX #>
        void Stepper(Step<T> step, <#= chain_AxisX_axisX #>);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        <#= documentation_AxisX_axisX #>
        StepStatus Stepper(StepBreak<T> function, <#= chain_AxisX_axisX #>);

        #endregion
    }

    public class OmnitreePointsLinked<T, <#= chain_AxisX #>> : IOmnitreePoints<T, <#= chain_AxisX #>>
    {
        private const int _dimensions = <#= i #>;
        internal static <#= child_index_type #> _children_per_node = (<#= child_index_type #>)BigInteger.Pow(2, <#= i #>);
        private const int _default_depth_load = 1; // starting and minimum depth load

        private Node _top;

		private int _naturalLogLower = 1; // caching the next time to calculate loads (lower count)
		private int _naturalLogUpper = -1; // caching the next time to calculate loads (upper count)
        private int _depth_load; // ln(count); min = _defaultLoad
        private int _node_load; // ln(count); min = _children_per_node
        private Omnitree.Location<T, Axis1<# for (int j = 2; j <= i; j++) { #>, Axis<#= j #><# } #>> _locate;

        private bool _defaultEquate;
        private Equate<T> _equate;

<# for (int j = 1; j <= i; j++) { #>
        private bool _defaultEquate<#= j #>;
        private Equate<Axis<#= j #>> _equate<#= j #>;
<# } #>

<# for (int j = 1; j <= i; j++) { #>
        private bool _defaultCompare<#= j #>;
        private Compare<Axis<#= j #>> _compare<#= j #>;
<# } #>

        // allows median overriding for custom optimizations (USE AT YOUR OWN RISK)<# for (int j = 1; j <= i; j++) { #>
        private Omnitree.SubdivisionOverride<T, Axis<#= j #>, Omnitree.Bounds<<#= chain_AxisX #>>> _subdivisionOverride<#= j #>;<# } #>

        #region Nested Types

        /// <summary>Can be a leaf or a branch.</summary>
        public abstract class Node
        {
            internal Omnitree.Bounds<<#= chain_AxisX #>> _bounds;
            internal Branch _parent;
            internal <#= child_index_type #> _index;
            internal int _count;

            /// <summary>The parent of this node.</summary>
            public Omnitree.Bounds<<#= chain_AxisX #>> Bounds { get { return this._bounds; } }
            /// <summary>The parent of this node.</summary>
            public Branch Parent { get { return this._parent; } }
            /// <summary>The computed child index of this node (see the "Notes" region in "Omnitree.cs" for the algorithm.</summary>
            public <#= child_index_type #> Index { get { return this._index; } }
            /// <summary>The number of elements stored in this node and its children.</summary>
            public int Count { get { return this._count; } set { this._count = value; } }

            /// <summary>The depth this node is located in the Omnitree.</summary>
            public int Depth
            {
                get
                {
                    int depth = -1;
                    for (Node looper = this; looper != null; looper = looper.Parent)
                        depth++;
                    return depth;
                }
            }

            /// <summary>Constructs a node.</summary>
            /// <param name="bounds">The bounds of this node.</param>
            /// <param name="parent">The parent of this node.</param>
            /// <param name="index">The number of elements stored in this node and its children.</param>
            public Node(Omnitree.Bounds<<#= chain_AxisX #>> bounds, Branch parent, <#= child_index_type #> index)
            {
                this._bounds = bounds;
                this._parent = parent;
                this._index = index;
            }

            internal Node(Node nodeToClone)
            {
                this._bounds = nodeToClone._bounds;
                this._parent = nodeToClone._parent;
                this._index = nodeToClone._index;
                this._count = nodeToClone._count;
            }

            internal abstract Node Clone();
        }

        /// <summary>A branch in the tree. Only contains nodes.</summary>
        public class Branch : Node
        {
            private Node[] _children;
            private Omnitree.Vector<<#= chain_AxisX #>> _pointOfDivision;

            public Node[] Children { get { return this._children; } set { this._children = value; } }
            public Omnitree.Vector<<#= chain_AxisX #>> PointOfDivision { get { return this._pointOfDivision; } internal set { this._pointOfDivision = value; } }
            
            /// <summary>Gets child by index.</summary>
            /// <param name="child_index">The index of the child to get.</param>
            /// <returns>The child of the given index or null if non-existent.</returns>
            public Node this[<#= child_index_type #> child_index]
            {
                get
                {
                    if (this._children == null)
                        return null;
                    if (this._children.Length == OmnitreePointsLinked<T, <#= chain_AxisX #>>._children_per_node)
                        return this._children[(int)child_index];
                    foreach (Node node in this._children)
                        if (node.Index == child_index)
                            return node;
                    return null;
                }
                set
                {
                    // This error check should be unnecessary... but fuck it... might as well
                    if (value.Index != child_index)
                        throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

                    // no children yet
                    if (this._children == null)
                    {
                        this._children = new Node[] { value };
                        return;
                    }
                    // max children overwrite
                    else if (this._children.Length == OmnitreePointsLinked<T, <#= chain_AxisX #>>._children_per_node)
                    {
                        this._children[(int)child_index] = value;
                        return;
                    }
                    // non-max child overwrite
                    for (int i = 0; i < this._children.Length; i++)
                        if (this._children[i].Index == child_index)
                        {
                            this._children[i] = value;
                            return;
                        }
                    // new child
                    Node[] newArray = new Node[this._children.Length + 1];
                    if (newArray.Length == OmnitreePointsLinked<T, <#= chain_AxisX #>>._children_per_node)
                    {
                        // new child resulting in a max children branch (sorting required)
                        for (int i = 0; i < this._children.Length; i++)
                        {
                            newArray[(int)this._children[i]._index] = this._children[i];
                        }
                        newArray[(int)value._index] = value;
                    }
                    else
                    {
                        // new child resulting in a non-max children branch
                        Array.Copy(this._children, newArray, this._children.Length);
                        newArray[newArray.Length - 1] = value;
                    }
                    this._children = newArray;
                }
            }

            public Branch(Omnitree.Vector<<#= chain_AxisX #>> pointOfDivision, Omnitree.Bounds<<#= chain_AxisX #>> bounds, Branch parent, <#= child_index_type #> index)
                : base(bounds, parent, index)
            {
                this._pointOfDivision = pointOfDivision;
            }

            public Branch(Branch branchToClone)
                : base(branchToClone)
            {
                this._children = branchToClone._children.Clone() as Node[];
                this._pointOfDivision = branchToClone._pointOfDivision;
            }

            internal override Node Clone()
            {
                return new Branch(this);
            }
        }

        /// <summary>A branch in the tree. Only contains items.</summary>
        public class Leaf : Node
        {
            public class Node
            {
                internal T _value;
                internal Leaf.Node _next;

                public T Value { get { return _value; } set { _value = value; } }
                public Leaf.Node Next { get { return _next; } set { _next = value; } }

                public Node(T value, Leaf.Node next)
                {
                    _value = value;
                    _next = next;
                }
            }

            private Leaf.Node _head;

            public Leaf.Node Head { get { return this._head; } set { this._head = value; } }

            internal Leaf(Omnitree.Bounds<<#= chain_AxisX #>> bounds, Branch parent, <#= child_index_type #> index)
                : base(bounds, parent, index)
            { }

            internal Leaf(Leaf leafToClone)
                : base(leafToClone)
            {
                this._head = new Node(leafToClone._head.Value, null);

                Node this_looper = this._head;
                Node other_looper = leafToClone._head;

                while (other_looper != null)
                {
                    this_looper.Next = new Node(other_looper.Next.Value, null);
                    this_looper = this_looper.Next;
                    other_looper = other_looper.Next;
                }
            }

            public void Add(T addition)
            {
                this._head = new Leaf.Node(addition, this._head);
                this.Count++;
            }

            internal override OmnitreePointsLinked<T, <#= chain_AxisX #>>.Node Clone()
            {
                return new Leaf(this);
            }
        }

        #endregion

        #region Constructors

        /// <summary>This constructor is for cloning purposes</summary>
        private OmnitreePointsLinked(OmnitreePointsLinked<T, <#= chain_AxisX #>> omnitree)
        {
            this._top = omnitree._top.Clone();
            this._depth_load = omnitree._depth_load;
            this._node_load = omnitree._node_load;
            this._locate = omnitree._locate;
            this._defaultEquate = omnitree._defaultEquate;
            this._equate = omnitree._equate;
<# for (int j = 1; j <= i; j++) { #>
            this._defaultEquate<#= j #> = omnitree._defaultEquate<#= j #>;
            this._equate<#= j #> = omnitree._equate<#= j #>;<# } #>
<# for (int j = 1; j <= i; j++) { #>
            this._defaultCompare<#= j #> = omnitree._defaultCompare<#= j #>;
            this._compare<#= j #> = omnitree._compare<#= j #>;<# } #>
<# for (int j = 1; j <= i; j++) { #>
            this._subdivisionOverride<#= j #> = omnitree._subdivisionOverride<#= j #>;<# } #>
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, <#= chain_AxisX #>> locate,

            bool defaultEquate,
            Equate<T> equate,
<# for (int j = 1; j <= i; j++) { #>
            bool defaultEquate<#= j #>,
            Equate<Axis<#= j #>> equateAxis<#= j #>,<# } #>
<# for (int j = 1; j <= i; j++) { #>
            bool defaultCompare<#= j #>,
            Compare<Axis<#= j #>> compare<#= j #>,<# } #>

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<<#= chain_AxisX #>>> subdivisionOverride1<# for (int j = 2; j <= i; j++) { #>,
            Omnitree.SubdivisionOverride<T, Axis<#= j #>, Omnitree.Bounds<<#= chain_AxisX #>>> subdivisionOverride<#= j #><# } #>)
        {
			if (locate == null)
			{
				throw new ArgumentNullException(nameof(locate));
			}
			if (equate == null)
			{
				throw new ArgumentNullException(nameof(equate));
			}
<# for (int j = 1; j <= i; j++) { #>
			if (equateAxis<#= j #> == null)
			{
				throw new ArgumentNullException(nameof(equateAxis<#= j #>));
			}<# } #>
<# for (int j = 1; j <= i; j++) { #>
			if (compare<#= j #> == null)
			{
				throw new ArgumentNullException(nameof(compare<#= j #>));
			}<# } #>

            this._locate = locate;
            this._defaultEquate = defaultEquate;
            this._equate = equate;
<# for (int j = 1; j <= i; j++) { #>
            this._defaultEquate<#= j #> = defaultEquate<#= j #>;
            this._equate<#= j #> = equateAxis<#= j #>;<# } #>
<# for (int j = 1; j <= i; j++) { #>
            this._defaultCompare<#= j #> = defaultCompare<#= j #>;
            this._compare<#= j #> = compare<#= j #>;<# } #>
<# for (int j = 1; j <= i; j++) { #>
            this._subdivisionOverride<#= j #> = subdivisionOverride<#= j #>;<# } #>

            this._top = new Leaf(Omnitree.Bounds<<#= chain_AxisX #>>.None, null, -1);
            ComputeLoads(0);
        }

        private OmnitreePointsLinked(
            Omnitree.Location<T, <#= chain_AxisX #>> locate,
            Equate<T> equate,
<# for (int j = 1; j <= i; j++) { #>
            Equate<Axis<#= j #>> equateAxis<#= j #>,<# } #>
<# for (int j = 1; j <= i; j++) { #>
            Compare<Axis<#= j #>> compare<#= j #>,<# } #>

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<<#= chain_AxisX #>>> subdivisionOverride1<# for (int j = 2; j <= i; j++) { #>,
            Omnitree.SubdivisionOverride<T, Axis<#= j #>, Omnitree.Bounds<<#= chain_AxisX #>>> subdivisionOverride<#= j #><# } #>)
            : this(
            locate,

            false,
            equate,
<# for (int j = 1; j <= i; j++) { #>
            false,
            equateAxis<#= j #>,<# } #>
<# for (int j = 1; j <= i; j++) { #>
            false,
            compare<#= j #>,<# } #>

            subdivisionOverride1<# for (int j = 2; j <= i; j++) { #>,
            subdivisionOverride<#= j #><# } #>)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, <#= chain_AxisX #>> locate,

            Equate<T> equate,
<# for (int j = 1; j <= i; j++) { #>
            Equate<Axis<#= j #>> equateAxis<#= j #>,<# } #>

            Compare<Axis1> compare1<# for (int j = 2; j <= i; j++) { #>,
            Compare<Axis<#= j #>> compare<#= j #><# } #>)
            : this(
                locate,

                false,
                equate,
<# for (int j = 1; j <= i; j++) { #>
                false,
                equateAxis<#= j #>,<# } #>
<# for (int j = 1; j <= i; j++) { #>
                false,
                compare<#= j #>,<# } #>

                null<# for (int j = 2; j <= i; j++) { #>,
                null<# } #>)
        { }



        public OmnitreePointsLinked(
            Omnitree.Location<T, <#= chain_AxisX #>> locate,

            Equate<T> equate,

            Compare<Axis1> compare1<# for (int j = 2; j <= i; j++) { #>,
            Compare<Axis<#= j #>> compare<#= j #><# } #>)
            : this(
                locate,
                false,
                equate,
<# for (int j = 1; j <= i; j++) { #>
                true,
                Towel.Equate.Default,<# } #>
<# for (int j = 1; j <= i; j++) { #>
                false,
                compare<#= j #>,<# } #>

                null<# for (int j = 2; j <= i; j++) { #>,
                null<# } #>)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, <#= chain_AxisX #>> locate,
            Equate<T> equate,
<# for (int j = 1; j <= i; j++) { #>
            Compare<Axis<#= j #>> compare<#= j #>,<# } #>

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<<#= chain_AxisX #>>> subdivisionOverride1<# for (int j = 2; j <= i; j++) { #>,
            Omnitree.SubdivisionOverride<T, Axis<#= j #>, Omnitree.Bounds<<#= chain_AxisX #>>> subdivisionOverride<#= j #><# } #>)
            : this(
                locate,

                false,
                equate,
<# for (int j = 1; j <= i; j++) { #>
                true,
                Towel.Equate.Default,<# } #>
<# for (int j = 1; j <= i; j++) { #>
                false,
                compare<#= j #>,<# } #>

                subdivisionOverride1<# for (int j = 2; j <= i; j++) { #>,
                subdivisionOverride<#= j #><# } #>)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, <#= chain_AxisX #>> locate,

            Compare<Axis1> compare1<# for (int j = 2; j <= i; j++) { #>,
            Compare<Axis<#= j #>> compare<#= j #><# } #>)
            : this(
                locate,
                true,
                Towel.Equate.Default,
<# for (int j = 1; j <= i; j++) { #>
                true,
                Towel.Equate.Default,<# } #>
<# for (int j = 1; j <= i; j++) { #>
                false,
                compare<#= j #>,<# } #>

                null<# for (int j = 2; j <= i; j++) { #>,
                null<# } #>)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, <#= chain_AxisX #>> locate,
<# for (int j = 1; j <= i; j++) { #>
            Compare<Axis<#= j #>> compare<#= j #>,<# } #>

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<<#= chain_AxisX #>>> subdivisionOverride1<# for (int j = 2; j <= i; j++) { #>,
            Omnitree.SubdivisionOverride<T, Axis<#= j #>, Omnitree.Bounds<<#= chain_AxisX #>>> subdivisionOverride<#= j #><# } #>)
            : this(
                locate,

                true,
                Towel.Equate.Default,
<# for (int j = 1; j <= i; j++) { #>
                true,
                Towel.Equate.Default,<# } #>
<# for (int j = 1; j <= i; j++) { #>
                false,
                compare<#= j #>,<# } #>

                subdivisionOverride1<# for (int j = 2; j <= i; j++) { #>,
                subdivisionOverride<#= j #><# } #>)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, <#= chain_AxisX #>> locate,
            Equate<T> equate)
            : this(
                locate,

                false,
                equate,
<# for (int j = 1; j <= i; j++) { #>
                true,
                Towel.Equate.Default,<# } #>
<# for (int j = 1; j <= i; j++) { #>
                true,
                Compare.Default,<# } #>

                null<# for (int j = 2; j <= i; j++) { #>,
                null<# } #>)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, <#= chain_AxisX #>> locate,
            Equate<T> equate,
            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<<#= chain_AxisX #>>> subdivisionOverride1<# for (int j = 2; j <= i; j++) { #>,
            Omnitree.SubdivisionOverride<T, Axis<#= j #>, Omnitree.Bounds<<#= chain_AxisX #>>> subdivisionOverride<#= j #><# } #>)
            : this(
                locate,

                false,
                equate,
<# for (int j = 1; j <= i; j++) { #>
                true,
                Towel.Equate.Default,<# } #>
<# for (int j = 1; j <= i; j++) { #>
                true,
                Compare.Default,<# } #>

                subdivisionOverride1<# for (int j = 2; j <= i; j++) { #>,
                subdivisionOverride<#= j #><# } #>)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, <#= chain_AxisX #>> locate)
            : this(
                locate,

                true,
                Towel.Equate.Default,
<# for (int j = 1; j <= i; j++) { #>
                true,
                Towel.Equate.Default,<# } #>
<# for (int j = 1; j <= i; j++) { #>
                true,
                Compare.Default,<# } #>

                null<# for (int j = 2; j <= i; j++) { #>,
                null<# } #>)
        { }

        public OmnitreePointsLinked(
            Omnitree.Location<T, <#= chain_AxisX #>> locate,
            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<<#= chain_AxisX #>>> subdivisionOverride1<# for (int j = 2; j <= i; j++) { #>,
            Omnitree.SubdivisionOverride<T, Axis<#= j #>, Omnitree.Bounds<<#= chain_AxisX #>>> subdivisionOverride<#= j #><# } #>)
            : this(
                locate,

                true,
                Towel.Equate.Default,
<# for (int j = 1; j <= i; j++) { #>
                true,
                Towel.Equate.Default,<# } #>
<# for (int j = 1; j <= i; j++) { #>
                true,
                Compare.Default,<# } #>

                subdivisionOverride1<# for (int j = 2; j <= i; j++) { #>,
                subdivisionOverride<#= j #><# } #>)
        { }

        #endregion

        #region Properties

        /// <summary>Steps through all the items at a given coordinate.</summary><# for (int j = 1; j <= i; j++) { #>
        /// <param name="axis<#= j #>">The coordinate along axis <#= j #>.</param><# } #>
        /// <returns>The stepper for the items at the given coordinate.</returns>
        public Stepper<T> this[<#= chain_AxisX_axisX #>]
        {
            get
            {
                return (Step<T> step) => { this.Stepper(step, <#= chain_axisX #>); };
            }
        }

        /// <summary>The number of dimensions in this tree.</summary>
        public int Dimensions { get { return _dimensions; } }

        /// <summary>The function for equating keys in this table.</summary>
        public Equate<T> Equate { get { return this._equate; } }

        /// <summary>The location function the Omnitree is using.</summary>
        public Omnitree.Location<T, <#= chain_AxisX #>> Locate { get { return this._locate; } }

<# for (int j = 1; j <= i; j++) { #>
        /// <summary>The comparison function the Omnitree is using along the <#= j #>D axis.</summary>
        public Compare<Axis<#= j #>> Compare<#= j #> { get { return this._compare<#= j #>; } }<# } #>
<# for (int j = 1; j <= i; j++) { #>
        /// <summary>The function for equating values along the <#= j #>D axis.</summary>
        public Equate<Axis<#= j #>> EquateAxis<#= j #> { get { return this._equate<#= j #>; } }<# } #>

        /// <summary>The current number of items in the tree.</summary>
        public int Count { get { return this._top.Count; } }

        private delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
        /// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int MaxDepth
        {
            get
            {
                MaxDepthFinder maxDepthFinder = null;
                maxDepthFinder =
                        (Node node, int current_depth, ref int max_depth) =>
                        {
                            if (current_depth > max_depth)
                                max_depth = current_depth;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    maxDepthFinder(child, current_depth + 1, ref max_depth);
                        };
                int _max_depth = -1;
                maxDepthFinder(this._top, 0, ref _max_depth);
                return _max_depth;
            }
        }

        private delegate void NodeCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int NodeCount
        {
            get
            {
                NodeCountFinder nodeCountFinder = null;
                nodeCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            current_count++;
                            if (node is Branch)
                                foreach (Node child in (node as Branch).Children)
                                    nodeCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                nodeCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void BranchCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of branches in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int BranchCount
        {
            get
            {
                BranchCountFinder branchCountFinder = null;
                branchCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Branch)
                            {
                                current_count++;
                                foreach (Node child in (node as Branch).Children)
                                    branchCountFinder(child, ref current_count);
                            }
                        };

                int _current_count = 0;
                branchCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        private delegate void LeafCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of leaves in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int LeafCount
        {
            get
            {
                LeafCountFinder leafCountFinder = null;
                leafCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            if (node is Leaf)
                                current_count++;
                            else
                                foreach (Node child in (node as Branch).Children)
                                    leafCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                leafCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        #endregion

        #region Methods

        #region Add

        #region Bulk

        public void Add(IndexedBigArray<T> additions, bool allowMultithreading)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= this._depth_load)
            {
                for (ulong i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
                ComputeLoads((int)additions.Length);

                Branch new_top = new Branch(Omnitree.Vector<<#= chain_AxisX #>>.Default, Omnitree.Bounds<<#= chain_AxisX #>>.None, null, -1);
                new_top.Count = (int)additions.Length;

<# for (int j = 1; j <= i; j++) { #>
                // prepare data for median computations
                IndexedBigArray<Axis<#= j #>> values<#= j #>;
                IAsyncResult result<#= j #> = null;
                if (this._subdivisionOverride<#= j #> != null)
                    values<#= j #> = null;
                else
                {
                    values<#= j #> = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values<#= j #> = new IndexedBigArray<Axis<#= j #>>(additions.Length);
                        for (ulong i = 0; i < additions.Length; i++)
                            values<#= j #>[i] = LocateVector(additions[i]).Axis<#= j #>;
                        Towel.Algorithms.Sort.Merge(this._compare<#= j #>, (int i) => { return values<#= j #>[(ulong)i]; }, (int i, Axis<#= j #> value) => { values<#= j #>[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result<#= j #> = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
<# } #>

<# for (int j = 1; j <= i; j++) { #>
                if (this._subdivisionOverride<#= j #> == null && allowMultithreading)
                    result<#= j #>.AsyncWaitHandle.WaitOne();
<# } #>

                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), (int)additions.Length, <# for (int j = 1; j <= i; j++) { #>int.MinValue, <# } #>(int)additions.Length, <# for (int j = 1; j <= i; j++) { #>(int index) => { return values<#= j #>[index]; }, <# } #>allowMultithreading);
                
                this._top = new_top;
            }
        }

        public void Add(bool allowMultithreading, params T[] additions)
        {
            if (additions.Length > int.MaxValue)
                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");

            if (this._top.Count != 0 || (int)additions.Length <= this._depth_load)
            {
                for (int i = 0; i < additions.Length; i++)
                    this.Add(additions[i]);
            }
            else
            {
                // adjust the loads prior to additions
                ComputeLoads((int)additions.Length);

                Branch new_top = new Branch(Omnitree.Vector<<#= chain_AxisX #>>.Default, Omnitree.Bounds<<#= chain_AxisX #>>.None, null, -1);
                new_top.Count = (int)additions.Length;

<# for (int j = 1; j <= i; j++) { #>
                // prepare data for median computations
                IndexedBigArray<Axis<#= j #>> values<#= j #>;
                IAsyncResult result<#= j #> = null;
                if (this._subdivisionOverride<#= j #> != null)
                    values<#= j #> = null;
                else
                {
                    values<#= j #> = null;
                    Towel.Parallels.Parallel.Operation operation = () =>
                    {
                        values<#= j #> = new IndexedBigArray<Axis<#= j #>>(additions.Length);
                        for (int i = 0; i < additions.Length; i++)
                            values<#= j #>[i] = LocateVector(additions[i]).Axis<#= j #>;
                        Towel.Algorithms.Sort.Merge(this._compare<#= j #>, (int i) => { return values<#= j #>[(ulong)i]; }, (int i, Axis<#= j #> value) => { values<#= j #>[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
                    };

                    if (allowMultithreading)
                        result<#= j #> = Towel.Parallels.Parallel.Thread(operation);
                    else
                        operation();
                }
<# } #>

<# for (int j = 1; j <= i; j++) { #>
                if (this._subdivisionOverride<#= j #> == null && allowMultithreading)
                    result<#= j #>.AsyncWaitHandle.WaitOne();
<# } #>

                // build the tree
                Add(new_top, 1, -1, additions.Stepper(), additions.Length, <# for (int j = 1; j <= i; j++) { #>int.MinValue, <# } #>(int)additions.Length, <# for (int j = 1; j <= i; j++) { #>(int index) => { return values<#= j #>[index]; }, <# } #>allowMultithreading);
                
                this._top = new_top;
            }
        }

        
        private int Add(Branch parent, int depth, <#= child_index_type #> child, Stepper<T> additions, int parent_count, <# for (int j = 1; j <= i; j++) { #>int prevmed<#= j #>, <# } #>int initial_count, <# for (int j = 1; j <= i; j++) { #>Get<Axis<#= j #>> values<#= j #>, <# } #>bool allowMultithreading)
        {<# for (int j = 1; j <= i; j++) { #>
            Axis<#= j #> pointOfDivision<#= j #>;<# } #>
<# for (int j = 1; j <= i; j++) { #>
            int median_axis<#= j #> = -1;<# } #>
            if (this._subdivisionOverride1 == null<# for (int j = 2; j <= i; j++) { #> || this._subdivisionOverride<#= j #> == null<# } #>)
                GetMedianIndexes(initial_count, child, depth, <# for (int j = 1; j <= i; j++) { #>prevmed<#= j #>, <# } #>out median_axis1<# for (int j = 2; j <= i; j++) { #>, out median_axis<#= j #><# } #>);
<# for (int j = 1; j <= i; j++) { #>
            if (this._subdivisionOverride<#= j #> != null)
                pointOfDivision<#= j #> = this._subdivisionOverride<#= j #>(parent.Bounds, additions);
            else
                pointOfDivision<#= j #> = values<#= j #>(median_axis<#= j #>);
<# } #>
            parent.PointOfDivision = new Omnitree.Vector<<#= chain_AxisX #>>(pointOfDivision1<# for (int j = 2; j <= i; j++) { #>, pointOfDivision<#= j #><# } #>);

            // divide the values along the medians
            IMap<IAddable<T>, <#= child_index_type #>> collection_map = new MapHashLinked<IAddable<T>, <#= child_index_type #>>();
            additions((T value) => 
            {
                <#= child_index_type #> index = DetermineChildIndex(parent.PointOfDivision, LocateVector(value));
                IAddable<T> list = null;
                if (collection_map.TryGet(index, out list))
                {
                    list.Add(value);
                }
                else
                {
                    if (parent_count < 100000)
                        list = new AddableArray<T>();
                    else
                        list = new AddableLinked<T>();
                    collection_map.Add(index, list);
                    list.Add(value);
                }
            });

            if (depth == 1 && allowMultithreading)
            {
                // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
                collection_map.Keys((<#= child_index_type #> key) => { parent[key] = new Leaf(Omnitree.Bounds<<#= chain_AxisX #>>.None, parent, key); });
                IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
                for (int i = 0; i < handles.Length; i++)
                {
                    int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
                    handles[i] = Towel.Parallels.Parallel.Thread(() =>
                    {
                        Step.EveryNth<Link<IAddable<T>, <#= child_index_type #>>>(collection_map.Pairs, multiTheadSafe_i + 1)(
                        (Link<IAddable<T>, <#= child_index_type #>> link) =>
                            {
                                ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, <# for (int j = 1; j <= i; j++) { #>median_axis<#= j #>, <# } #>initial_count, <# for (int j = 1; j <= i; j++) { #>values<#= j #>, <# } #>allowMultithreading);
                            });
                    });
                }
                
                foreach (IAsyncResult handle in handles)
                {
                    handle.AsyncWaitHandle.WaitOne();
                }
            }
            else
            {
                collection_map.Pairs((Link<IAddable<T>, <#= child_index_type #>> link) =>
                { 
                    ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, <# for (int j = 1; j <= i; j++) { #>median_axis<#= j #>, <# } #>initial_count, <# for (int j = 1; j <= i; j++) { #>values<#= j #>, <# } #>allowMultithreading);
                });
            }

            int count = 0;
            foreach (Node node in parent.Children)
                count += node.Count;
            return count;
        }

        int ReversedChildBuilding(Branch parent, <#= child_index_type #> child_index, int depth, Stepper<T> additions, int count, <# for (int j = 1; j <= i; j++) { #>int prevmed<#= j #>, <# } #>int initial_count, <# for (int j = 1; j <= i; j++) { #>Get<Axis<#= j #>> values<#= j #>, <# } #>bool allowMultithreading)
        {
            Omnitree.Bounds<<#= chain_AxisX #>> child_bounds = DetermineChildBounds(parent, child_index);
            if (depth >= this._depth_load || count <= this._node_load)
            {
                Leaf new_leaf = new Leaf(child_bounds, parent, child_index);
                additions((T value) => { new_leaf.Add(value); });
                parent[new_leaf.Index] = new_leaf;
                return new_leaf.Count;
            }
            else
            {
                Branch new_branch = new Branch(Omnitree.Vector<<#= chain_AxisX #>>.Default, child_bounds, parent, child_index);
                parent[new_branch.Index] = new_branch;
                new_branch.Count = Add(new_branch, depth + 1, child_index, additions, count, <# for (int j = 1; j <= i; j++) { #>prevmed<#= j #>, <# } #>count, <# for (int j = 1; j <= i; j++) { #>values<#= j #>, <# } #>allowMultithreading);
                return new_branch.Count;
            }
        }

        /// <summary>Gets the indeces of the median values at the given position during bulk additions.</summary>
        private void GetMedianIndexes(int count, <#= child_index_type #> child_index, int depth, <# for (int j = 1; j <= i; j++) { #>int previous<#= j #>, <# } #>out int index1<# for (int j = 2; j <= i; j++) { #>, out int index<#= j #><# } #>)
        {
            if (depth == 1)
            {<# for (int j = 1; j <= i; j++) { #>
                index<#= j #> = (count - 1) / 2;<# } #>
                return;
            }

            int splits = Compute.Power(2, depth);
            int mid_child_range = count / splits;
<# for (int j = i; j >= 1; j--) { #>
            if (child_index >= <#= (2 << (j - 1)) / 2 #>)
            {
                index<#= j #> = previous<#= j #> + mid_child_range;
                child_index -= <#= (2 << (j - 1)) / 2 #>;
            }
            else
            {
                index<#= j #> = previous<#= j #> - mid_child_range;
            }
<# } #>
        }

        #endregion

        #region single

        /// <summary>Adds an item to the tree.</summary>
        /// <param name="addition">The item to be added.</param>
        public void Add(T addition)
        {
            if (this._top.Count == int.MaxValue)
                throw new System.InvalidOperationException("(Count == int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

            // dynamic tree sizes
            ComputeLoads(this._top.Count);

            Omnitree.Vector<<#= chain_AxisX #>> location = LocateVector(addition);

            // grow the first branch of the tree
            if (this._top is Leaf && (this._top as Leaf).Count >= this._node_load)
            {
                Leaf top = this._top as Leaf;

                // create the new branch from the median values
                this._top = new Branch(DetermineMedians(top), Omnitree.Bounds<<#= chain_AxisX #>>.None, null, -1);

                // iterate through the elements and add them to the appropriate children
                for (Leaf.Node list = top.Head; list != null; list = list.Next)
                    Add(list.Value, this._top, LocateVector(list.Value), 0);
            }

            this.Add(addition, this._top, location, 0);
        }
        
        /// <summary>Recursive version of the add function.</summary>
        /// <param name="addition">The item to be added.</param>
        /// <param name="node">The current node for tree trversal.</param>
        /// <param name="ms">The location of the addition.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private void Add(T addition, Node node, Omnitree.Vector<<#= chain_AxisX #>> location, int depth)
        {
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                if (depth >= this._depth_load || !(leaf.Count >= this._node_load))
                {
                    leaf.Add(addition);
                    return;
                }
                else
                {
                    Branch parent = node.Parent;
                    <#= child_index_type #> child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
                    Branch growth = new Branch(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
                    parent[child_index] = growth;
                    for (Leaf.Node list = leaf.Head; list != null; list = list.Next)
                    {
                        Omnitree.Vector<<#= chain_AxisX #>> temp_location = LocateVector(list.Value);
                        if (EncapsulationCheck(growth.Bounds, temp_location))
                            Add(list.Value, growth, temp_location, depth);
                        else
                        {
                            ReduceParentCounts(parent, 1);
                            Add(list.Value, this._top, temp_location, depth);
                        }
                    }

                    Add(addition, growth, location, depth);
                    return;
                }
            }
            else
            {
                Branch branch = node as Branch;
                <#= child_index_type #> child_index = this.DetermineChildIndex(branch.PointOfDivision, location); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
                Node child_node = branch[child_index];

                // null children in branches are just empty leaves
                if (child_node == null)
                {
                    Leaf new_leaf = new Leaf(DetermineChildBounds(branch, child_index), branch, child_index);
                    branch[child_index] = new_leaf;
                    new_leaf.Add(addition);
                }
                else
                    // child exists already, continue adding
                    Add(addition, child_node, location, depth + 1);

                branch.Count++;
                return;
            }
        }

        /// <summary>Determins the dimensions of the child at the given index.</summary>
        /// <param name="leaf">The parent of the node to compute dimensions for.</param>
        /// <param name="child">The index of the child to compute dimensions for.</param>
        /// <param name="median1">The computed minimum dimensions of the child node along the 1D axis.</param>
        /// <param name="median2">The computed minimum dimensions of the child node along the 2D axis.</param>
        /// <param name="median3">The computed minimum dimensions of the child node along the 3D axis.</param>
        private Omnitree.Vector<<#= chain_AxisX #>> DetermineMedians(Leaf leaf)
        {
            try
            {
                // extract the values<# for (int j = 1; j <= i; j++) { #>
                Axis<#= j #>[] values<#= j #> = new Axis<#= j #>[leaf.Count];<# } #>
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                    this._locate(for_current.Value, out values1[i]<# for (int j = 2; j <= i; j++) { #>, out values<#= j #>[i]<# } #>);
                // sort the values<# for (int j = 1; j <= i; j++) { #>
                if (_defaultCompare<#= j #>) Array.Sort(values<#= j #>);
                else Array.Sort(values<#= j #>, Compare.ToSystemComparison(this._compare<#= j #>));<# } #>
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<<#= chain_AxisX #>>(values1[index]<# for (int j = 2; j <= i; j++) { #>, values<#= j #>[index]<# } #>);
            }
            catch (Exception exception)
            {
				System.Diagnostics.Debugger.Break();
                // extract the values<# for (int j = 1; j <= i; j++) { #>
                IndexedBigArray<Axis<#= j #>> values<#= j #> = new IndexedBigArray<Axis<#= j #>>(leaf.Count);<# } #>
                Leaf.Node for_current = leaf.Head; // used in for loop
                for (int i = 0; i < leaf.Count; i++, for_current = for_current.Next)
                {<# for (int j = 1; j <= i; j++) { #>
                    Axis<#= j #> value<#= j #>;<# } #>
                    this._locate(for_current.Value, out value1<# for (int j = 2; j <= i; j++) { #>, out value<#= j #><# } #>);<# for (int j = 1; j <= i; j++) { #>
                    values<#= j #>[i] = value<#= j #>;<# } #>
                }
                // sort the values<# for (int j = 1; j <= i; j++) { #>
                if (_defaultCompare<#= j #>) Towel.Algorithms.Sort.Merge(Compare.Default, (int sorting_index) => { return values<#= j #>[sorting_index]; }, (int sorting_index, Axis<#= j #> axis<#= j #>) => { values<#= j #>[sorting_index] = axis<#= j #>; }, 0, (int)values1.Length);
                else Towel.Algorithms.Sort.Merge(_compare<#= j #>, (int sorting_index) => { return values<#= j #>[sorting_index]; }, (int sorting_index, Axis<#= j #> axis<#= j #>) => { values<#= j #>[sorting_index] = axis<#= j #>; }, 0, (int)values1.Length);<# } #>
                // pull out the lazy medians (if even # of items... just take the left)
                int index = (leaf.Count - 1) / 2;
                return new Omnitree.Vector<<#= chain_AxisX #>>(values1[index]<# for (int j = 2; j <= i; j++) { #>, values<#= j #>[index]<# } #>);
            }
        }

        #endregion

        #region Add Helpers

        private Omnitree.Bounds<<#= chain_AxisX #>> DetermineChildBounds(Branch branch, <#= child_index_type #> child_index)
        {
<# for (int j = i; j >= 1; j--) { #>
            Omnitree.Bound<Axis<#= j #>> min<#= j #>, max<#= j #>;
            if (child_index >= <#= (2 << (j - 1)) / 2 #>)
            {
                min<#= j #> = branch.PointOfDivision.Axis<#= j #>;
                max<#= j #> = branch.Bounds.Max<#= j #>;
                child_index -= <#= (2 << (j - 1)) / 2 #>;
            }
            else
            {
                min<#= j #> = branch.Bounds.Min<#= j #>;
                max<#= j #> = branch.PointOfDivision.Axis<#= j #>;
            }
<# } #>
            return new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>);
        }

        #endregion

        #endregion

        #region Clear

        /// <summary>Returns the tree to an empty state.</summary>
        public void Clear()
        {
            this._top = new Leaf(Omnitree.Bounds<<#= chain_AxisX #>>.None, null, -1);
            ComputeLoads(0);
        }

        #endregion

        #region Clone

        /// <summary>Creates a shallow clone of this data structure.</summary>
        /// <returns>A shallow clone of this data structure.</returns>
        public OmnitreePointsLinked<T, <#= chain_AxisX #>> Clone()
        {
            return new OmnitreePointsLinked<T, <#= chain_AxisX #>>(this);
        }

        #endregion

        #region Count

        /// <summary>Counts the number of items in a sub space.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(<#= chain_AxisX_minX_AxisX_maxX #>)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(<#= chain_BoundAxisX_minX_BoundAxisX_maxX #>)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        <#= documentation_AxisX_axisX #>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(<#= chain_AxisX_axisX #>)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_axisX_axisX #>));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        <#= documentation_AxisX_axisX #>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpace(<#= chain_BoundAxisX_axisX #>)
        {
            return CountSubSpace(_top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_axisX_axisX #>));
        }
        /// <summary>Counts the number of items in a sub space.</summary>
        /// <param name="node">The current traversal node.</param>
        /// <returns>The number of items in the provided sub space.</returns>
        private int CountSubSpace(Node node, Omnitree.Bounds<<#= chain_AxisX #>> bounds)
        {
            // adjust min/max values
            int count = 0;
            if (EncapsulationCheck(bounds, node.Bounds))
                count += node.Count;
            else if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        count++;
            }
            else
            {
                Branch branch = node as Branch;
                if (!StraddlesLines(branch.Bounds, branch.PointOfDivision))
                {
                    <#= child_index_type #> child_index = DetermineChildIndex(branch.PointOfDivision, new Omnitree.Vector<<#= chain_AxisX #>>(bounds.Min1.Value<# for (int j = 2; j <= i; j++) { #>, bounds.Min<#= j #>.Value<# } #>));
                    Node child = branch[child_index];
                    if (child != null)
                      count += this.CountSubSpace(child, bounds);
                }
                else
                {
                    foreach (Node child in (node as Branch).Children)
                        count += this.CountSubSpace(child, bounds);
                }
            }
            return count;
        }

        #endregion

        #region Update

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        public void Update()
        {
            this.Update(this._top, 0);
        }

        /// <summary>Recursive version of the Update method.</summary>
        /// <param name="node">The current node of iteration.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private int Update(Node node, int depth)
        {
            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<<#= chain_AxisX #>> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;

                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);

                        if (whereToAdd == null)
                            throw new System.Exception("an item was updated outside the range of the omnitree");

                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        public void Update(<#= chain_AxisX_minX_AxisX_maxX #>)
        {
            this.Update(new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        public void Update(<#= chain_BoundAxisX_minX_BoundAxisX_maxX #>)
        {
            this.Update(new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        <#= documentation_AxisX_axisX #>
        public void Update(<#= chain_AxisX_axisX #>)
        {
            this.Update(new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_axisX_axisX #>), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        <#= documentation_AxisX_axisX #>
        public void Update(<#= chain_BoundAxisX_axisX #>)
        {
            this.Update(new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_axisX_axisX #>), this._top, 0);
        }
        private int Update(Omnitree.Bounds<<#= chain_AxisX #>> bounds, Node node, int depth)
        {
            if (!InclusionCheck(bounds, node.Bounds))
                return 0;

            int removals = 0;

            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    Omnitree.Vector<<#= chain_AxisX #>> location = LocateVector(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, location))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                        Node whereToAdd = GetEncapsulationParent(node.Parent, location);
                        if (whereToAdd == null)
                            throw new System.Exception("an item was updates outside the range of the omnitree");
                        this.Add(updated, whereToAdd, location, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        #endregion

        #region Remove

        /// <summary>Removes all the items qualified by the delegate.</summary>
        /// <param name="where">The predicate to qualify removals.</param>
        public void Remove(Predicate<T> where)
        {
            this.Remove(this._top, where);
            ComputeLoads(this._top.Count);
        }

        /// <summary>Recursive version of the remove method.</summary>
        /// <param name="node">The current node of traversal.</param>
        /// <param name="where">The predicate to qualify removals.</param>
        private int Remove(Node node, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                while (leaf.Head != null && where(leaf.Head.Value))
                {
                    leaf.Head = leaf.Head.Next;
                    removals++;
                }
                if (leaf.Head != null)
                {
                    Leaf.Node list = leaf.Head;
                    while (list.Next != null)
                    {
                        if (where(list.Next.Value))
                        {
                            list.Next = list.Next.Next;
                            removals++;
                        }
                    }
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);

                return removals;
            }
        }

        /// <summary>Removes all the items in a given space.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(<#= chain_AxisX_minX_AxisX_maxX #>)
        {
            this.Remove(this._top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>));
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(<#= chain_BoundAxisX_minX_BoundAxisX_maxX #>)
        {
            this.Remove(this._top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>));
            ComputeLoads(this._top.Count);
        }
        private int Remove(Node node, Omnitree.Bounds<<#= chain_AxisX #>> bounds)
        {
            int removals = 0;
            if (InclusionCheck(bounds, node.Bounds))
            {
                if (node is Leaf)
                {
                    Leaf leaf = node as Leaf;
                    Leaf.Node current_node = leaf.Head;
                    Leaf.Node previous_node = null;
                    while (current_node != null)
                    {
                        Leaf.Node temp_previous = current_node;
                        if (EncapsulationCheck(bounds, LocateVector(current_node.Value)))
                        {
                            removals++;
                            if (current_node == leaf.Head)
                                leaf.Head = leaf.Head.Next;
                            else
                            {
                                previous_node.Next = current_node.Next;
                                temp_previous = previous_node;
                            }
                        }
                        previous_node = temp_previous;
                        current_node = current_node.Next;
                    }
                    leaf.Count -= removals;
                }
                else
                {
                    Branch branch = node as Branch;
                    int skipped = 0;
                    for (int i = 0; i + skipped < branch.Children.Length; )
                    {
                        removals += this.Remove(branch.Children[i], bounds);
                        if (branch.Children[i].Count == 0)
                            branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                        else
                            i++;
                    }
                    Node[] newArray = new Node[branch.Children.Length - skipped];
                    Array.Copy(branch.Children, newArray, newArray.Length);
                    branch.Children = newArray;

                    branch.Count -= removals;
                    // convert this branch back into a leaf
                    // Note: if count is zero, it will be chopped off
                    if (branch.Count < this._depth_load && branch.Count > 0)
                        ShrinkChild(branch.Parent, branch.Index);
                }
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(<#= chain_AxisX_minX_AxisX_maxX #>, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>), where);
            ComputeLoads(this._top.Count);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(<#= chain_BoundAxisX_minX_BoundAxisX_maxX #>, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>), where);
            ComputeLoads(this._top.Count);
        }
        private int Remove(Node node, Omnitree.Bounds<<#= chain_AxisX #>> bounds, Predicate<T> where)
        {
            if (!InclusionCheck(node.Bounds, bounds))
                return 0;
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current = leaf.Head;
                Leaf.Node previous = null;
                while (current != null)
                {
                    if (this.EncapsulationCheck(bounds, LocateVector(current.Value)) && where(current.Value))
                    {
                        removals++;
                        if (previous == null)
                        {
                            leaf.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }

                leaf.Count -= removals;
                return removals;
            }
            else
            {
                Branch branch = node as Branch;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Remove(branch.Children[i], bounds, where);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                node.Count -= removals;

                if (node.Count < this._depth_load && node.Count != 0)
                    ShrinkChild(node.Parent, node.Index);

                return removals;
            }
        }

        /// <summary>Removes all instances of a given value.</summary>
        public void Remove(T removal)
        {<# for (int j = 1; j <= i; j++) { #>
            Axis<#= j #> axis<#= j #>;<# } #>
            this._locate(removal, out axis1<# for (int j = 2; j <= i; j++) { #>, out axis<#= j #><# } #>);
            this.Remove(<# for (int j = 1; j <= i; j++) { #>axis<#= j #>, <# } #>(T item) => { return this._equate(item, removal); });
        }
        /// <summary>Removes all the items in a given space.</summary>
        <#= documentation_axisX #>
        /// <returns>The number of items that were removed.</returns>
        public void Remove(Axis1 axis1<# for (int j = 2; j <= i; j++) { #>, Axis<#= j #> axis<#= j #><# } #>)
        {
            this.Remove(this._top, new Omnitree.Vector<<#= chain_AxisX #>>(axis1<# for (int j = 2; j <= i; j++) { #>, axis<#= j #><# } #>));
            ComputeLoads(this._top.Count);
        }
        private int Remove(Node node, Omnitree.Vector<<#= chain_AxisX #>> vector)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                <#= child_index_type #> child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < this._depth_load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        <#= documentation_axisX #>
        /// <param name="where">The equality constraint of the removal.</param>
        public void Remove(<#= chain_AxisX_axisX #>, Predicate<T> where)
        {
            this.Remove(this._top, new Omnitree.Vector<<#= chain_AxisX #>>(<#= chain_axisX #>), where);
            ComputeLoads(this._top.Count);
        }
        private int Remove(Node node, Omnitree.Vector<<#= chain_AxisX #>> vector, Predicate<T> where)
        {
            int removals = 0;
            if (node is Leaf)
            {
                Leaf leaf = node as Leaf;
                Leaf.Node current_node = leaf.Head;
                Leaf.Node previous_node = null;
                while (current_node != null)
                {
                    Leaf.Node temp_previous = current_node;
                    if (EqualsCheck(vector, LocateVector(current_node.Value)) && where(current_node.Value))
                    {
                        removals++;
                        if (current_node == leaf.Head)
                            leaf.Head = leaf.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                leaf.Count -= removals;
            }
            else
            {
                Branch branch = node as Branch;
                <#= child_index_type #> child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                removals += Remove(branch[child_index], vector, where);
                branch.Count -= removals;
                // convert this branch back into a leaf
                // Note: if count is zero, it will be chopped off
                if (branch.Count < this._depth_load && branch.Count > 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }
            return removals;
        }

        #endregion

        #region Stepper And IEnumerable

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public void Stepper(Step<T> function)
        {
            this.Stepper(function, this._top);
        }
        private void Stepper(Step<T> function, Node node)
        {
            if (node is Leaf)
            {
                Leaf.Node list = (node as Leaf).Head;
                while (list != null)
                {
                    function(list.Value);
                    list = list.Next;
                }
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    this.Stepper(function, child);
            }
        }

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public StepStatus Stepper(StepBreak<T> function)
        {
            return Stepper(function, _top);
        }
        private StepStatus Stepper(StepBreak<T> function, Node node)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (Code.ReturnAssign(ref status, function(list._value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    if (Code.ReturnAssign(ref status, Stepper(function, child)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        public void Stepper(Step<T> function, <#= chain_AxisX_minX_AxisX_maxX #>)
        {
            Stepper(function, _top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        public void Stepper(Step<T> function, <#= chain_BoundAxisX_minX_BoundAxisX_maxX #>)
        {
            Stepper(function, _top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Bounds<<#= chain_AxisX #>> bounds)
        {
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)))
                        function(list.Value);
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds))
                        this.Stepper(function, child);
                    else if (InclusionCheck(child.Bounds, bounds))
                        this.Stepper(function, child, bounds);
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        public StepStatus Stepper(StepBreak<T> function, <#= chain_AxisX_minX_AxisX_maxX #>)
        {
            return Stepper(function, _top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        public StepStatus Stepper(StepBreak<T> function, <#= chain_BoundAxisX_minX_BoundAxisX_maxX #>)
        {
            return Stepper(function, _top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>));
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Bounds<<#= chain_AxisX #>> bounds)
        {
            StepStatus status = StepStatus.Continue;
            if (node is Leaf)
            {
                for (Leaf.Node list = (node as Leaf).Head; list != null; list = list.Next)
                    if (EncapsulationCheck(bounds, LocateVector(list.Value)) &&
                        Code.ReturnAssign(ref status, function(list.Value)) != StepStatus.Continue)
                        break;
            }
            else
            {
                foreach (Node child in (node as Branch).Children)
                    // optimization: stop bounds checking if space encapsulates node
                    if (EncapsulationCheck(bounds, child.Bounds) &&
                        Code.ReturnAssign(ref status, this.Stepper(function, child)) != StepStatus.Continue)
                        break;
                    else if (!InclusionCheck(child.Bounds, bounds) &&
                        Code.ReturnAssign(ref status, this.Stepper(function, child, bounds)) != StepStatus.Continue)
                        break;
            }
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        <#= documentation_axisX #>
        public void Stepper(Step<T> function, <#= chain_AxisX_axisX #>)
        {
            Stepper(function, _top, new Omnitree.Vector<<#= chain_AxisX #>>(<#= chain_axisX #>));
        }
        private void Stepper(Step<T> function, Node node, Omnitree.Vector<<#= chain_AxisX #>> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node leaf_node = (current as Leaf).Head; leaf_node != null; leaf_node = leaf_node.Next)
                        if (EqualsCheck(vector, LocateVector(leaf_node.Value)))
                            function(leaf_node.Value);
                    break;
                }
                else
                {
                    Branch branch = current as Branch;
                    <#= child_index_type #> child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        <#= documentation_axisX #>
        public StepStatus Stepper(StepBreak<T> function, <#= chain_AxisX_axisX #>)
        {
            return Stepper(function, _top, new Omnitree.Vector<<#= chain_AxisX #>>(<#= chain_axisX #>));
        }
        private StepStatus Stepper(StepBreak<T> function, Node node, Omnitree.Vector<<#= chain_AxisX #>> vector)
        {
            Node current = node;
            while (current != null)
            {
                if (current is Leaf)
                {
                    for (Leaf.Node list = (current as Leaf).Head; list != null; list = list.Next)
                    {
                        StepStatus status = StepStatus.Continue;
                        if (EqualsCheck(vector, LocateVector(list.Value)) &&
                            Code.ReturnAssign(ref status, function(list.Value)) != StepStatus.Continue)
                            return status;
                    }
                }
                else
                {
                    Branch branch = current as Branch;
                    <#= child_index_type #> child_index = DetermineChildIndex(branch.PointOfDivision, vector);
                    current = branch[child_index];
                }
            }
            return StepStatus.Continue;
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        #endregion

        #region Helpers

        private bool StraddlesLines(Omnitree.Bounds<<#= chain_AxisX #>> bounds, Omnitree.Vector<<#= chain_AxisX #>> vector)
        {<# for (int j = 1; j <= i; j++) { #>
			if ((!bounds.Min<#= j #>.Exists || (bounds.Min<#= j #>.Exists && this._compare<#= j #>(bounds.Min<#= j #>.Value, vector.Axis<#= j #>) != Comparison.Greater)) &&
				(!bounds.Max<#= j #>.Exists || (bounds.Max<#= j #>.Exists && this._compare<#= j #>(bounds.Max<#= j #>.Value, vector.Axis<#= j #>) != Comparison.Less)))
				return true;<# } #>
            return false;
        }

        /// <summary>Computes the child index that contains the desired dimensions.</summary>
        /// <param name="node">The branch .</param>
        /// <param name="vector">The dimensions to determine the child index.</param>
        /// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
        private <#= child_index_type #> DetermineChildIndex(Omnitree.Vector<<#= chain_AxisX #>> pointOfDivision, Omnitree.Vector<<#= chain_AxisX #>> vector)
        {
            <#= child_index_type #> child = 0;<# for (int j = 1; j <= i; j++) { #>
            if (!(this._compare<#= j #>(vector.Axis<#= j #>, pointOfDivision.Axis<#= j #>) == Comparison.Less))
                child += 1 << <#= j - 1 #>;<# } #>
            return child;
        }

        /// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
        /// <param name="parent">The parent to shrink a child of.</param>
        /// <param name="child">The index of the child to shrink.</param>
        private void ShrinkChild(Branch parent, <#= child_index_type #> child_index)
        {
            Leaf leaf;
            Node removal = null;
            if (parent == null) // top of tree
            {
                removal = this._top;
                leaf = new Leaf(Omnitree.Bounds<<#= chain_AxisX #>>.None, null, -1);
                this._top = leaf;
            }
            else // non-top branch
            {
                removal = parent[child_index];
                leaf = new Leaf(removal.Bounds, removal.Parent, removal.Index);
                parent[child_index] = leaf;
            }

            this.Stepper((T step) => { leaf.Add(step); }, removal);
        }

        /// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the reduction.</param>
        /// <param name="reduction">The amount to reduce the parent counts by.</param>
        private void ReduceParentCounts(Node parent, int reduction)
        {
            IncreaseParentCounts(parent, -reduction);
        }

        /// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the increase.</param>
        /// <param name="increase">The amount to increase the parent counts by.</param>
        private void IncreaseParentCounts(Node parent, int increase)
        {
            Node looper = parent;
            while (looper != null)
            {
                looper.Count += increase;
                looper = looper.Parent;
            }
        }

        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        private bool InclusionCheck(Omnitree.Bounds<<#= chain_AxisX #>> a, Omnitree.Bounds<<#= chain_AxisX #>> b)
        {
<# for (int j = 1; j <= i; j++) { #>
            if (a.Max<#= j #>.Exists && b.Min<#= j #>.Exists && this._compare<#= j #>(a.Max<#= j #>.Value, b.Min<#= j #>.Value) == Comparison.Less)
                return false;
            else if (a.Min<#= j #>.Exists && b.Max<#= j #>.Exists && this._compare<#= j #>(a.Min<#= j #>.Value, b.Max<#= j #>.Value) == Comparison.Greater)
                return false;
<# } #>
            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<<#= chain_AxisX #>> bounds, Omnitree.Vector<<#= chain_AxisX #>> vector)
        {
            // if the location is not outside the bounds, it must be inside
<# for (int j = 1; j <= i; j++) { #>
            if (bounds.Min<#= j #>.Exists && this._compare<#= j #>(vector.Axis<#= j #>, bounds.Min<#= j #>.Value) == Comparison.Less)
                return false;
            else if (bounds.Max<#= j #>.Exists && this._compare<#= j #>(vector.Axis<#= j #>, bounds.Max<#= j #>.Value) == Comparison.Greater)
                return false;
<# } #>
            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<<#= chain_AxisX #>> a, Omnitree.Bounds<<#= chain_AxisX #>> b)
        {
            if ((a.Min1.Exists && !b.Min1.Exists)<# for (int j = 2; j <= i; j++) { #> || (a.Min<#= j #>.Exists && !b.Min<#= j #>.Exists)<# } #>)
                return false;
			if ((a.Max1.Exists && !b.Max1.Exists)<# for (int j = 2; j <= i; j++) { #> || (a.Max<#= j #>.Exists && !b.Max<#= j #>.Exists)<# } #>)
                return false;
<# for (int j = 1; j <= i; j++) { #>
            if (b.Min<#= j #>.Exists && a.Min<#= j #>.Exists && this._compare<#= j #>(a.Min<#= j #>.Value, b.Min<#= j #>.Value) != Comparison.Less)
                return false;
            if (b.Max<#= j #>.Exists && a.Max<#= j #>.Exists && this._compare<#= j #>(a.Max<#= j #>.Value, b.Max<#= j #>.Value) != Comparison.Greater)
                return false;
<# } #>
            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        private bool EqualsCheck(Omnitree.Vector<<#= chain_AxisX #>> a, Omnitree.Vector<<#= chain_AxisX #>> b)
        {
<# for (int j = 1; j <= i; j++) { #>
            if (!this._equate<#= j #>(a.Axis<#= j #>, b.Axis<#= j #>))
                return false;
<# } #>
            return true;
        }

        /// <summary>Gets the nearest parent that encapsulates a location.</summary>
        /// <param name="node">The starting node to find the encapsulating parent of the location.</param>
        /// <param name="coordinate1">The coordinate along the 1D axis.</param>
        /// <param name="coordinate2">The coordinate along the 2D axis.</param>
        /// <param name="coordinate3">The coordinate along the 3D axis.</param>
        /// <returns>The nearest node that encapsulates the given location.</returns>
        private Node GetEncapsulationParent(Node node, Omnitree.Vector<<#= chain_AxisX #>> vector)
        {
            while (node != null && !EncapsulationCheck(node.Bounds, vector))
                node = node.Parent;
            return node;
        }

        /// <summary>Checks for required load reduction.</summary>
        private void ComputeLoads(int count)
        {
            if (count < _naturalLogLower || count > _naturalLogUpper)
			{
				int naturalLog = (int)Math.Log(count);
				_naturalLogLower = (int)Math.Pow(Math.E, naturalLog);
				_naturalLogUpper = (int)Math.Pow(Math.E, naturalLog + 1);

				_naturalLogLower = Math.Min(count - 10, _naturalLogLower);
				_naturalLogUpper = Math.Max(2, _naturalLogUpper);
				naturalLog = Math.Max(2, naturalLog);

				this._depth_load = Compute.Maximum(naturalLog, _default_depth_load);
				this._node_load = (int)Compute.Maximum(naturalLog, _children_per_node);
			}
        }

        private Omnitree.Vector<<#= chain_AxisX #>> LocateVector(T value)
        {<# for (int j = 1; j <= i; j++) { #>
            Axis<#= j #> axis<#= j #>;<# } #>
            this._locate(value, out axis1<# for (int j = 2; j <= i; j++) { #>, out axis<#= j #><# } #>);
            return new Omnitree.Vector<<#= chain_AxisX #>>(<#= chain_axisX #>);
        }

        #endregion

        #endregion
    }

    #endregion<# } #>

    #endregion

	#region OmnitreeBounds
    
    // NOTE: the ND version can be found int "Omnitree_ND.cs"<# foreach (int i in dimensionsToGenerate) { #>
<# // ------------------------------------------------------------------------------------------------------------------------------ 
 // PARAMETER/ARGUMENT CHAINS
      string chain_AxisX = "Axis1"; for (int j = 2; j <= i; j++) { chain_AxisX += ", Axis" + j; } 
      string chain_axisX = "axis1"; for (int j = 2; j <= i; j++) { chain_axisX += ", axis" + j; } 
      string chain_AxisX_axisX = "Axis1 axis1"; for (int j = 2; j <= i; j++) { chain_AxisX_axisX += ", Axis" + j + " axis" + j; }
      string chain_AxisX_minX_AxisX_maxX = "Axis1 min1, Axis1 max1"; for (int j = 2; j <= i; j++) { chain_AxisX_minX_AxisX_maxX += ", Axis" + j + " min" + j + ", Axis" + j + " max" + j; }
      string chain_BoundAxisX_minX_BoundAxisX_maxX = "Omnitree.Bound<Axis1> min1, Omnitree.Bound<Axis1> max1"; for (int j = 2; j <= i; j++) { chain_BoundAxisX_minX_BoundAxisX_maxX += ", Omnitree.Bound<Axis" + j + "> min" + j + ", Omnitree.Bound<Axis" + j + "> max" + j; }
      string chain_BoundAxisX_axisX = "Omnitree.Bound<Axis1> axis1"; for (int j = 2; j <= i; j++) { chain_BoundAxisX_axisX += ", Omnitree.Bound<Axis" + j + "> axis" + j; }
      string chain_minX_maxX = "min1, max1"; for (int j = 2; j <= i; j++) { chain_minX_maxX += ", min" + j + ", max" + j; }
      string chain_axisX_axisX = "axis1, axis1"; for (int j = 2; j <= i; j++) { chain_axisX_axisX += ", axis" + j + ", axis" + j; }
      string child_index_type; if (i <= 30) { child_index_type = "int"; } else if (i <= 60) { child_index_type = "long"; } else { child_index_type = "BigInteger"; }
 // DOCUMENTATION
      string documentation_AxisX_axisX = string.Empty; for (int j = 1; j <= i; j++) { documentation_AxisX_axisX += "\n\t\t/// <param name=\"axis" + j + "\">The coordinate along the " + j + "D axis.</param>"; } documentation_AxisX_axisX = documentation_AxisX_axisX.Trim();
      string documentation_AxisX_minX_AxisX_maxX = string.Empty; for (int j = 1; j <= i; j++) { documentation_AxisX_minX_AxisX_maxX += "\n\t\t/// <param name=\"min" + j + "\">The minimum coordinate of the space along the " + j + " axis.</param>\n\t\t/// <param name=\"max" + j + "\">The maximum coordinate of the space along the " + j + " axis.</param>"; } documentation_AxisX_minX_AxisX_maxX = documentation_AxisX_minX_AxisX_maxX.Trim();
      string documentation_axisX = string.Empty; for (int j = 1; j <= i; j++) { documentation_axisX += "\n\t\t/// <param name=\"axis" + j + "\">The axis of the removal along the  " + j + "D axis.</param>"; } documentation_axisX = documentation_axisX.Trim();
 // ------------------------------------------------------------------------------------------------------------------------------ #>
    #region <#= i #> Dimensional

    public interface IOmnitreeBounds<T, <#= chain_AxisX #>> : IDataStructure<T>,
            DataStructure.ICountable,
            DataStructure.IAddable<T>,
            DataStructure.IClearable,
            DataStructure.IRemovable<T>,
            DataStructure.IEquating<T>
    {
        #region Properties

        /// <summary>The number of dimensions in this tree.</summary>
        int Dimensions { get; }

        #endregion

        #region Methods

        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpaceEncapsulated(<#= chain_AxisX_minX_AxisX_maxX #>);

		/// <summary>Counts the number of items overlapped by a sub space.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        /// <returns>The number of items in the provided sub space.</returns>
        int CountSubSpaceOverlapped(<#= chain_AxisX_minX_AxisX_maxX #>);

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        void Update();
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        void Update(<#= chain_AxisX_minX_AxisX_maxX #>);

        /// <summary>Removes all the items in a given space.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        void RemoveEncapsulated(<#= chain_AxisX_minX_AxisX_maxX #>);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        /// <param name="where">The predicate constraint of the removal.</param>
        void RemoveEncapsulated(<#= chain_AxisX_minX_AxisX_maxX #>, Predicate<T> where);

		/// <summary>Removes all the items in a given space.</summary>
        <#= documentation_AxisX_axisX #>
        void RemoveOverlapped(<#= chain_AxisX_axisX #>);
        /// <summary>Removes all the items in a given space.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        void RemoveOverlapped(<#= chain_AxisX_minX_AxisX_maxX #>);
        /// <summary>Removes all the items in a given space where equality is met.</summary>
        <#= documentation_AxisX_axisX #>
        /// <param name="where">The equality constraint of the removal.</param>
        void RemoveOverlapped(<#= chain_AxisX_axisX #>, Predicate<T> where);
        /// <summary>Removes all the items in a given space where predicate is met.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        /// <param name="where">The predicate constraint of the removal.</param>
        void RemoveOverlapped(<#= chain_AxisX_minX_AxisX_maxX #>, Predicate<T> where);

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        void StepperEncapsulated(Step<T> step, <#= chain_BoundAxisX_minX_BoundAxisX_maxX #>);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        StepStatus StepperEncapsulated(StepBreak<T> step, <#= chain_BoundAxisX_minX_BoundAxisX_maxX #>);
        
		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        void StepperOverlapped(Step<T> step, <#= chain_BoundAxisX_minX_BoundAxisX_maxX #>);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        StepStatus StepperOverlapped(StepBreak<T> step, <#= chain_BoundAxisX_minX_BoundAxisX_maxX #>);

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        <#= documentation_AxisX_axisX #>
        void StepperOverlapped(Step<T> step, <#= chain_AxisX_axisX #>);
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="step">The step function to perform on all items in the tree within the given bounds.</param>
        <#= documentation_AxisX_axisX #>
        StepStatus StepperOverlapped(StepBreak<T> function, <#= chain_AxisX_axisX #>);

        #endregion
    }

    public class OmnitreeBoundsLinked<T, <#= chain_AxisX #>> : IOmnitreeBounds<T, <#= chain_AxisX #>>
    {
        private const int _dimensions = <#= i #>;
        internal static <#= child_index_type #> _children_per_node = (<#= child_index_type #>)BigInteger.Pow(2, <#= i #>);
        private const int _default_depth_load = 1; // starting and minimum depth load

        private Node _top;

		private int _naturalLogLower = 1; // caching the next time to calculate loads (lower count)
		private int _naturalLogUpper = -1; // caching the next time to calculate loads (upper count)
        private int _depth_load; // ln(count); min = _defaultLoad
        private int _node_load; // ln(count); min = _children_per_node
        private Omnitree.GetBounds<T, Axis1<# for (int j = 2; j <= i; j++) { #>, Axis<#= j #><# } #>> _getBounds;

        private bool _defaultEquate;
        private Equate<T> _equate;

<# for (int j = 1; j <= i; j++) { #>
        private bool _defaultEquate<#= j #>;
        private Equate<Axis<#= j #>> _equate<#= j #>;
<# } #>

<# for (int j = 1; j <= i; j++) { #>
        private bool _defaultCompare<#= j #>;
        private Compare<Axis<#= j #>> _compare<#= j #>;
<# } #>

        // allows median overriding for custom optimizations (USE AT YOUR OWN RISK)<# for (int j = 1; j <= i; j++) { #>
        private Omnitree.SubdivisionOverride<T, Axis<#= j #>, Omnitree.Bounds<<#= chain_AxisX #>>> _subdivisionOverride<#= j #>;<# } #>

        #region Nested Types

        /// <summary>Can be a leaf or a branch.</summary>
        internal class Node
        {
            public class ValueNode
            {
                internal T _value;
                internal ValueNode _next;

                public T Value { get { return _value; } set { _value = value; } }
                public ValueNode Next { get { return _next; } set { _next = value; } }

                public ValueNode(T value, ValueNode next)
                {
                    _value = value;
                    _next = next;
                }
            }

            internal Omnitree.Bounds<<#= chain_AxisX #>> _bounds;
            internal Node _parent;
            internal <#= child_index_type #> _index;
            internal int _count;
            internal ValueNode _head;
            private Node[] _children;
            private Omnitree.Vector<<#= chain_AxisX #>>? _pointOfDivision;

            /// <summary>The parent of this node.</summary>
            public Omnitree.Bounds<<#= chain_AxisX #>> Bounds { get { return this._bounds; } }
            /// <summary>The parent of this node.</summary>
            public Node Parent { get { return this._parent; } }
            /// <summary>The computed child index of this node (see the "Notes" region in "Omnitree.cs" for the algorithm.</summary>
            public <#= child_index_type #> Index { get { return this._index; } }
            /// <summary>The number of elements stored in this node and its children.</summary>
            public int Count { get { return this._count; } set { this._count = value; } }
            /// <summary>The first object stored in this node.</summary>
            public ValueNode Head { get { return this._head; } set { this._head = value; } }
            public Node[] Children { get { return this._children; } set { this._children = value; } }
            public Omnitree.Vector<<#= chain_AxisX #>>? PointOfDivision { get { return this._pointOfDivision; } internal set { this._pointOfDivision = value; } }

            /// <summary>Gets child by index.</summary>
            /// <param name="child_index">The index of the child to get.</param>
            /// <returns>The child of the given index or null if non-existent.</returns>
            public Node this[<#= child_index_type #> child_index]
            {
                get
                {
                    if (this._children == null)
                        return null;
                    if (this._children.Length == OmnitreePointsLinked<T, <#= chain_AxisX #>>._children_per_node)
                        return this._children[(int)child_index];
                    foreach (Node node in this._children)
                        if (node.Index == child_index)
                            return node;
                    return null;
                }
                set
                {
                    // This error check should be unnecessary... but fuck it... might as well
                    if (value.Index != child_index)
                        throw new System.Exception("Bug in Omnitree (index/property mis-match when setting a child on a branch)");

                    // no children yet
                    if (this._children == null)
                    {
                        this._children = new Node[] { value };
                        return;
                    }
                    // max children overwrite
                    else if (this._children.Length == OmnitreePointsLinked<T, <#= chain_AxisX #>>._children_per_node)
                    {
                        this._children[(int)child_index] = value;
                        return;
                    }
                    // non-max child overwrite
                    for (int i = 0; i < this._children.Length; i++)
                        if (this._children[i].Index == child_index)
                        {
                            this._children[i] = value;
                            return;
                        }
                    // new child
                    Node[] newArray = new Node[this._children.Length + 1];
                    if (newArray.Length == OmnitreePointsLinked<T, <#= chain_AxisX #>>._children_per_node)
                    {
                        // new child resulting in a max children branch (sorting required)
                        for (int i = 0; i < this._children.Length; i++)
                        {
                            newArray[(int)this._children[i]._index] = this._children[i];
                        }
                        newArray[(int)value._index] = value;
                    }
                    else
                    {
                        // new child resulting in a non-max children branch
                        Array.Copy(this._children, newArray, this._children.Length);
                        newArray[newArray.Length - 1] = value;
                    }
                    this._children = newArray;
                }
            }

            /// <summary>The depth this node is located in the Omnitree.</summary>
            public int Depth
            {
                get
                {
                    int depth = -1;
                    for (Node looper = this; looper != null; looper = looper.Parent)
                        depth++;
                    return depth;
                }
            }

            /// <summary>Constructs a node.</summary>
            /// <param name="bounds">The bounds of this node.</param>
            /// <param name="parent">The parent of this node.</param>
            /// <param name="index">The number of elements stored in this node and its children.</param>
            public Node(Omnitree.Bounds<<#= chain_AxisX #>> bounds, Node parent, <#= child_index_type #> index)
            {
                this._bounds = bounds;
                this._parent = parent;
                this._index = index;
            }

            public Node(Omnitree.Vector<<#= chain_AxisX #>> pointOfDivision, Omnitree.Bounds<<#= chain_AxisX #>> bounds, Node parent, <#= child_index_type #> index)
                : this(bounds, parent, index)
            {
                this._pointOfDivision = pointOfDivision;
            }

            internal Node(Node nodeToClone)
            {
                this._bounds = nodeToClone._bounds;
                this._parent = nodeToClone._parent;
                this._index = nodeToClone._index;
                this._count = nodeToClone._count;

                this._children = nodeToClone._children.Clone() as Node[];
                this._pointOfDivision = nodeToClone._pointOfDivision;

                ValueNode this_looper = this._head;
                ValueNode other_looper = nodeToClone._head;

                while (other_looper != null)
                {
                    this_looper.Next = new ValueNode(other_looper.Next.Value, null);
                    this_looper = this_looper.Next;
                    other_looper = other_looper.Next;
                }
            }

            public void Add(T addition)
            {
                this._head = new ValueNode(addition, this._head);
                this.Count++;
            }

            internal Node Clone()
            {
                return new Node(this);
            }
        }
        
        #endregion

        #region Constructors

        /// <summary>This constructor is for cloning purposes</summary>
        private OmnitreeBoundsLinked(OmnitreeBoundsLinked<T, <#= chain_AxisX #>> omnitree)
        {
            this._top = omnitree._top.Clone();
            this._depth_load = omnitree._depth_load;
            this._node_load = omnitree._node_load;
            this._getBounds = omnitree._getBounds;
            this._defaultEquate = omnitree._defaultEquate;
            this._equate = omnitree._equate;
<# for (int j = 1; j <= i; j++) { #>
            this._defaultEquate<#= j #> = omnitree._defaultEquate<#= j #>;
            this._equate<#= j #> = omnitree._equate<#= j #>;<# } #>
<# for (int j = 1; j <= i; j++) { #>
            this._defaultCompare<#= j #> = omnitree._defaultCompare<#= j #>;
            this._compare<#= j #> = omnitree._compare<#= j #>;<# } #>
<# for (int j = 1; j <= i; j++) { #>
            this._subdivisionOverride<#= j #> = omnitree._subdivisionOverride<#= j #>;<# } #>
        }

        private OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, <#= chain_AxisX #>> getBounds,

            bool defaultEquate,
            Equate<T> equate,
<# for (int j = 1; j <= i; j++) { #>
            bool defaultEquate<#= j #>,
            Equate<Axis<#= j #>> equateAxis<#= j #>,<# } #>
<# for (int j = 1; j <= i; j++) { #>
            bool defaultCompare<#= j #>,
            Compare<Axis<#= j #>> compare<#= j #>,<# } #>

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<<#= chain_AxisX #>>> subdivisionOverride1<# for (int j = 2; j <= i; j++) { #>,
            Omnitree.SubdivisionOverride<T, Axis<#= j #>, Omnitree.Bounds<<#= chain_AxisX #>>> subdivisionOverride<#= j #><# } #>)
        {
			if (getBounds == null)
			{
				throw new ArgumentNullException(nameof(getBounds));
			}
			if (equate == null)
			{
				throw new ArgumentNullException(nameof(equate));
			}
<# for (int j = 1; j <= i; j++) { #>
			if (equateAxis<#= j #> == null)
			{
				throw new ArgumentNullException(nameof(equateAxis<#= j #>));
			}<# } #>
<# for (int j = 1; j <= i; j++) { #>
			if (compare<#= j #> == null)
			{
				throw new ArgumentNullException(nameof(compare<#= j #>));
			}<# } #>

            this._getBounds = getBounds;
            this._defaultEquate = defaultEquate;
            this._equate = equate;
<# for (int j = 1; j <= i; j++) { #>
            this._defaultEquate<#= j #> = defaultEquate<#= j #>;
            this._equate<#= j #> = equateAxis<#= j #>;<# } #>
<# for (int j = 1; j <= i; j++) { #>
            this._defaultCompare<#= j #> = defaultCompare<#= j #>;
            this._compare<#= j #> = compare<#= j #>;<# } #>
<# for (int j = 1; j <= i; j++) { #>
            this._subdivisionOverride<#= j #> = subdivisionOverride<#= j #>;<# } #>

            this._top = new Node(Omnitree.Bounds<<#= chain_AxisX #>>.None, null, -1);
            ComputeLoads(0);
        }

        private OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, <#= chain_AxisX #>> getBounds,
            Equate<T> equate,
<# for (int j = 1; j <= i; j++) { #>
            Equate<Axis<#= j #>> equateAxis<#= j #>,<# } #>
<# for (int j = 1; j <= i; j++) { #>
            Compare<Axis<#= j #>> compare<#= j #>,<# } #>

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<<#= chain_AxisX #>>> subdivisionOverride1<# for (int j = 2; j <= i; j++) { #>,
            Omnitree.SubdivisionOverride<T, Axis<#= j #>, Omnitree.Bounds<<#= chain_AxisX #>>> subdivisionOverride<#= j #><# } #>)
            : this(
            getBounds,

            false,
            equate,
<# for (int j = 1; j <= i; j++) { #>
            false,
            equateAxis<#= j #>,<# } #>
<# for (int j = 1; j <= i; j++) { #>
            false,
            compare<#= j #>,<# } #>

            subdivisionOverride1<# for (int j = 2; j <= i; j++) { #>,
            subdivisionOverride<#= j #><# } #>)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, <#= chain_AxisX #>> getBounds,

            Equate<T> equate,
<# for (int j = 1; j <= i; j++) { #>
            Equate<Axis<#= j #>> equateAxis<#= j #>,<# } #>

            Compare<Axis1> compare1<# for (int j = 2; j <= i; j++) { #>,
            Compare<Axis<#= j #>> compare<#= j #><# } #>)
            : this(
                getBounds,

                false,
                equate,
<# for (int j = 1; j <= i; j++) { #>
                false,
                equateAxis<#= j #>,<# } #>
<# for (int j = 1; j <= i; j++) { #>
                false,
                compare<#= j #>,<# } #>

                null<# for (int j = 2; j <= i; j++) { #>,
                null<# } #>)
        { }



        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, <#= chain_AxisX #>> getBounds,

            Equate<T> equate,

            Compare<Axis1> compare1<# for (int j = 2; j <= i; j++) { #>,
            Compare<Axis<#= j #>> compare<#= j #><# } #>)
            : this(
                getBounds,
                false,
                equate,
<# for (int j = 1; j <= i; j++) { #>
                true,
                Towel.Equate.Default,<# } #>
<# for (int j = 1; j <= i; j++) { #>
                false,
                compare<#= j #>,<# } #>

                null<# for (int j = 2; j <= i; j++) { #>,
                null<# } #>)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, <#= chain_AxisX #>> getBounds,
            Equate<T> equate,
<# for (int j = 1; j <= i; j++) { #>
            Compare<Axis<#= j #>> compare<#= j #>,<# } #>

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<<#= chain_AxisX #>>> subdivisionOverride1<# for (int j = 2; j <= i; j++) { #>,
            Omnitree.SubdivisionOverride<T, Axis<#= j #>, Omnitree.Bounds<<#= chain_AxisX #>>> subdivisionOverride<#= j #><# } #>)
            : this(
                getBounds,

                false,
                equate,
<# for (int j = 1; j <= i; j++) { #>
                true,
                Towel.Equate.Default,<# } #>
<# for (int j = 1; j <= i; j++) { #>
                false,
                compare<#= j #>,<# } #>

                subdivisionOverride1<# for (int j = 2; j <= i; j++) { #>,
                subdivisionOverride<#= j #><# } #>)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, <#= chain_AxisX #>> getBounds,

            Compare<Axis1> compare1<# for (int j = 2; j <= i; j++) { #>,
            Compare<Axis<#= j #>> compare<#= j #><# } #>)
            : this(
                getBounds,
                true,
                Towel.Equate.Default,
<# for (int j = 1; j <= i; j++) { #>
                true,
                Towel.Equate.Default,<# } #>
<# for (int j = 1; j <= i; j++) { #>
                false,
                compare<#= j #>,<# } #>

                null<# for (int j = 2; j <= i; j++) { #>,
                null<# } #>)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, <#= chain_AxisX #>> getBounds,
<# for (int j = 1; j <= i; j++) { #>
            Compare<Axis<#= j #>> compare<#= j #>,<# } #>

            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<<#= chain_AxisX #>>> subdivisionOverride1<# for (int j = 2; j <= i; j++) { #>,
            Omnitree.SubdivisionOverride<T, Axis<#= j #>, Omnitree.Bounds<<#= chain_AxisX #>>> subdivisionOverride<#= j #><# } #>)
            : this(
                getBounds,

                true,
                Towel.Equate.Default,
<# for (int j = 1; j <= i; j++) { #>
                true,
                Towel.Equate.Default,<# } #>
<# for (int j = 1; j <= i; j++) { #>
                false,
                compare<#= j #>,<# } #>

                subdivisionOverride1<# for (int j = 2; j <= i; j++) { #>,
                subdivisionOverride<#= j #><# } #>)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, <#= chain_AxisX #>> getBounds,
            Equate<T> equate)
            : this(
                getBounds,

                false,
                equate,
<# for (int j = 1; j <= i; j++) { #>
                true,
                Towel.Equate.Default,<# } #>
<# for (int j = 1; j <= i; j++) { #>
                true,
                Compare.Default,<# } #>

                null<# for (int j = 2; j <= i; j++) { #>,
                null<# } #>)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, <#= chain_AxisX #>> getBounds,
            Equate<T> equate,
            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<<#= chain_AxisX #>>> subdivisionOverride1<# for (int j = 2; j <= i; j++) { #>,
            Omnitree.SubdivisionOverride<T, Axis<#= j #>, Omnitree.Bounds<<#= chain_AxisX #>>> subdivisionOverride<#= j #><# } #>)
            : this(
                getBounds,

                false,
                equate,
<# for (int j = 1; j <= i; j++) { #>
                true,
                Towel.Equate.Default,<# } #>
<# for (int j = 1; j <= i; j++) { #>
                true,
                Compare.Default,<# } #>

                subdivisionOverride1<# for (int j = 2; j <= i; j++) { #>,
                subdivisionOverride<#= j #><# } #>)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, <#= chain_AxisX #>> getBounds)
            : this(
                getBounds,

                true,
                Towel.Equate.Default,
<# for (int j = 1; j <= i; j++) { #>
                true,
                Towel.Equate.Default,<# } #>
<# for (int j = 1; j <= i; j++) { #>
                true,
                Compare.Default,<# } #>

                null<# for (int j = 2; j <= i; j++) { #>,
                null<# } #>)
        { }

		public OmnitreeBoundsLinked(
            Omnitree.GetBoundings<T, <#= chain_AxisX #>> getBoundings)
            : this(
                Omnitree.ConvertToGetBounds(getBoundings),

                true,
                Towel.Equate.Default,
<# for (int j = 1; j <= i; j++) { #>
                true,
                Towel.Equate.Default,<# } #>
<# for (int j = 1; j <= i; j++) { #>
                true,
                Compare.Default,<# } #>

                null<# for (int j = 2; j <= i; j++) { #>,
                null<# } #>)
        { }

        public OmnitreeBoundsLinked(
            Omnitree.GetBounds<T, <#= chain_AxisX #>> getBounds,
            Omnitree.SubdivisionOverride<T, Axis1, Omnitree.Bounds<<#= chain_AxisX #>>> subdivisionOverride1<# for (int j = 2; j <= i; j++) { #>,
            Omnitree.SubdivisionOverride<T, Axis<#= j #>, Omnitree.Bounds<<#= chain_AxisX #>>> subdivisionOverride<#= j #><# } #>)
            : this(
                getBounds,

                true,
                Towel.Equate.Default,
<# for (int j = 1; j <= i; j++) { #>
                true,
                Towel.Equate.Default,<# } #>
<# for (int j = 1; j <= i; j++) { #>
                true,
                Compare.Default,<# } #>

                subdivisionOverride1<# for (int j = 2; j <= i; j++) { #>,
                subdivisionOverride<#= j #><# } #>)
        { }

        #endregion

        #region Properties

        /// <summary>The number of dimensions in this tree.</summary>
        public int Dimensions { get { return _dimensions; } }

        /// <summary>The function for equating keys in this table.</summary>
        public Equate<T> Equate { get { return this._equate; } }

        /// <summary>The location function the Omnitree is using.</summary>
        public Omnitree.GetBounds<T, <#= chain_AxisX #>> GetBounds { get { return this._getBounds; } }
<# for (int j = 1; j <= i; j++) { #>
        /// <summary>The comparison function the Omnitree is using along the <#= j #>D axis.</summary>
        public Compare<Axis<#= j #>> Compare<#= j #> { get { return this._compare<#= j #>; } }<# } #>
<# for (int j = 1; j <= i; j++) { #>
        /// <summary>The function for equating values along the <#= j #>D axis.</summary>
        public Equate<Axis<#= j #>> EquateAxis<#= j #> { get { return this._equate<#= j #>; } }<# } #>

        /// <summary>The current number of items in the tree.</summary>
        public int Count { get { return this._top.Count; } }

        private delegate void MaxDepthFinder(Node node, int current_depth, ref int max_depth);
        /// <summary>Finds the current maximum depth of the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int MaxDepth
        {
            get
            {
                MaxDepthFinder maxDepthFinder = null;
                maxDepthFinder =
                        (Node node, int current_depth, ref int max_depth) =>
                        {
                            if (current_depth > max_depth)
                                max_depth = current_depth;
                            foreach (Node child in node.Children)
                                maxDepthFinder(child, current_depth + 1, ref max_depth);
                        };
                int _max_depth = -1;
                maxDepthFinder(this._top, 0, ref _max_depth);
                return _max_depth;
            }
        }

        private delegate void NodeCountFinder(Node node, ref int current_count);
        /// <summary>Counts the current number of nodes in the tree. NOT AN O(1) OPERATION. Intended for educational purposes only.</summary>
        public int NodeCount
        {
            get
            {
                NodeCountFinder nodeCountFinder = null;
                nodeCountFinder =
                        (Node node, ref int current_count) =>
                        {
                            current_count++;
                            foreach (Node child in node.Children)
                                nodeCountFinder(child, ref current_count);
                        };

                int _current_count = 0;
                nodeCountFinder(this._top, ref _current_count);
                return _current_count;
            }
        }

        #endregion

        #region Methods

        #region Add

        #region Bulk

		// not yet implemented

//        public void Add(IndexedBigArray<T> additions, bool allowMultithreading)
//        {
//            if (additions.Length > int.MaxValue)
//                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");
//
//            if (this._top.Count != 0 || (int)additions.Length <= this._depth_load)
//            {
//                for (ulong i = 0; i < additions.Length; i++)
//                    this.Add(additions[i]);
//            }
//            else
//            {
//                // adjust the loads prior to additions
//                ComputeLoads((int)additions.Length);
//
//                Node new_top = new Node(Omnitree.Bounds<<#= chain_AxisX #>>.None, null, -1);
//                new_top.Count = (int)additions.Length;
//
//<# for (int j = 1; j <= i; j++) { #>
//                // prepare data for median computations
//                IndexedBigArray<Axis<#= j #>> values<#= j #>;
//                IAsyncResult result<#= j #> = null;
//                if (this._subdivisionOverride<#= j #> != null)
//                    values<#= j #> = null;
//                else
//                {
//                    values<#= j #> = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values<#= j #> = new IndexedBigArray<Axis<#= j #>>(additions.Length * 2);
//                        for (ulong i = 0; i < additions.Length; i++)
//						{
//							Omnitree.Bounds<<#= chain_AxisX #>> bounds = GetBoundings(additions[i]);
//                            values<#= j #>[i * 2] = bounds.Min1;
//							values<#= j #>[i * 2 + 1] = bounds.Max1;
//						}
//
//                        Towel.Algorithms.Sort.Merge(this._compare<#= j #>, (int i) => { return values<#= j #>[(ulong)i]; }, (int i, Axis<#= j #> value) => { values<#= j #>[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result<#= j #> = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//<# } #>
//
//<# for (int j = 1; j <= i; j++) { #>
//                if (this._subdivisionOverride<#= j #> == null && allowMultithreading)
//                    result<#= j #>.AsyncWaitHandle.WaitOne();<# } #>
//
//                // build the tree
//                Add(new_top, 1, -1, additions.Stepper(), (int)additions.Length, <# for (int j = 1; j <= i; j++) { #>int.MinValue, <# } #>(int)additions.Length, <# for (int j = 1; j <= i; j++) { #>(int index) => { return values<#= j #>[index]; }, <# } #>allowMultithreading);
//                
//                this._top = new_top;
//            }
//        }
//
//        public void Add(bool allowMultithreading, params T[] additions)
//        {
//            if (additions.Length > int.MaxValue)
//                throw new System.Exception("The maximum size of the Omnitree was exceeded during bulk addition.");
//
//            if (this._top.Count != 0 || (int)additions.Length <= this._depth_load)
//            {
//                for (int i = 0; i < additions.Length; i++)
//                    this.Add(additions[i]);
//            }
//            else
//            {
//                // adjust the loads prior to additions
//                ComputeLoads((int)additions.Length);
//
//                Node new_top = new Node(Omnitree.Bounds<<#= chain_AxisX #>>.None, null, -1);
//                new_top.Count = (int)additions.Length;
//
//<# for (int j = 1; j <= i; j++) { #>
//                // prepare data for median computations
//                IndexedBigArray<Axis<#= j #>> values<#= j #>;
//                IAsyncResult result<#= j #> = null;
//                if (this._subdivisionOverride<#= j #> != null)
//                    values<#= j #> = null;
//                else
//                {
//                    values<#= j #> = null;
//                    Towel.Parallels.Parallel.Operation operation = () =>
//                    {
//                        values<#= j #> = new IndexedBigArray<Axis<#= j #>>(additions.Length);
//                        for (int i = 0; i < additions.Length; i++)
//                            values<#= j #>[i] = LocateVector(additions[i]).Axis<#= j #>;
//                        Towel.Algorithms.Sort.Merge(this._compare<#= j #>, (int i) => { return values<#= j #>[(ulong)i]; }, (int i, Axis<#= j #> value) => { values<#= j #>[(ulong)i] = value; }, 0, (int)(additions.Length - 1));
//                    };
//
//                    if (allowMultithreading)
//                        result<#= j #> = Towel.Parallels.Parallel.Thread(operation);
//                    else
//                        operation();
//                }
//<# } #>
//
//<# for (int j = 1; j <= i; j++) { #>
//                if (this._subdivisionOverride<#= j #> == null && allowMultithreading)
//                    result<#= j #>.AsyncWaitHandle.WaitOne();
//<# } #>
//
//                // build the tree
//                Add(new_top, 1, -1, additions.Stepper(), additions.Length, <# for (int j = 1; j <= i; j++) { #>int.MinValue, <# } #>(int)additions.Length, <# for (int j = 1; j <= i; j++) { #>(int index) => { return values<#= j #>[index]; }, <# } #>allowMultithreading);
//                
//                this._top = new_top;
//            }
//        }
//
//        
//        private int Add(Node parent, int depth, <#= child_index_type #> child, Stepper<T> additions, int parent_count, <# for (int j = 1; j <= i; j++) { #>int prevmed<#= j #>, <# } #>int initial_count, <# for (int j = 1; j <= i; j++) { #>Get<Axis<#= j #>> values<#= j #>, <# } #>bool allowMultithreading)
//        {<# for (int j = 1; j <= i; j++) { #>
//            Axis<#= j #> pointOfDivision<#= j #>;<# } #>
//<# for (int j = 1; j <= i; j++) { #>
//            int median_axis<#= j #> = -1;<# } #>
//            if (this._subdivisionOverride1 == null<# for (int j = 2; j <= i; j++) { #> || this._subdivisionOverride<#= j #> == null<# } #>)
//                GetMedianIndexes(initial_count, child, depth, <# for (int j = 1; j <= i; j++) { #>prevmed<#= j #>, <# } #>out median_axis1<# for (int j = 2; j <= i; j++) { #>, out median_axis<#= j #><# } #>);
//<# for (int j = 1; j <= i; j++) { #>
//            if (this._subdivisionOverride<#= j #> != null)
//                pointOfDivision<#= j #> = this._subdivisionOverride<#= j #>(parent.Bounds, additions);
//            else
//                pointOfDivision<#= j #> = values<#= j #>(median_axis<#= j #>);
//<# } #>
//            parent.PointOfDivision = new Omnitree.Vector<<#= chain_AxisX #>>(pointOfDivision1<# for (int j = 2; j <= i; j++) { #>, pointOfDivision<#= j #><# } #>);
//
//            // divide the values along the medians
//            IMap<IAddable<T>, <#= child_index_type #>> collection_map = new MapHashLinked<IAddable<T>, <#= child_index_type #>>();
//            additions((T value) => 
//            {
//                <#= child_index_type #> index = DetermineChildIndex(parent.PointOfDivision.Value, LocateVector(value));
//                IAddable<T> list = null;
//                if (collection_map.TryGet(index, out list))
//                {
//                    list.Add(value);
//                }
//                else
//                {
//                    if (parent_count < 100000)
//                        list = new AddableArray<T>();
//                    else
//                        list = new AddableLinked<T>();
//                    collection_map.Add(index, list);
//                    list.Add(value);
//                }
//            });
//
//            if (depth == 1 && allowMultithreading)
//            {
//                // NOTE: Must assign placeholders before multithreading so that the threads do not overwrite each other
//                collection_map.Keys((<#= child_index_type #> key) => { parent[key] = new Node(Omnitree.Bounds<<#= chain_AxisX #>>.None, parent, key); });
//                IAsyncResult[] handles = new IAsyncResult[Environment.ProcessorCount];
//                for (int i = 0; i < handles.Length; i++)
//                {
//                    int multiTheadSafe_i = i; // used as catpure variable below making it multithread-safe
//                    handles[i] = Towel.Parallels.Parallel.Thread(() =>
//                    {
//                        Step.EveryNth<Link<IAddable<T>, <#= child_index_type #>>>(collection_map.Pairs, multiTheadSafe_i + 1)(
//                        (Link<IAddable<T>, <#= child_index_type #>> link) =>
//                            {
//                                ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, <# for (int j = 1; j <= i; j++) { #>median_axis<#= j #>, <# } #>initial_count, <# for (int j = 1; j <= i; j++) { #>values<#= j #>, <# } #>allowMultithreading);
//                            });
//                    });
//                }
//                
//                foreach (IAsyncResult handle in handles)
//                {
//                    handle.AsyncWaitHandle.WaitOne();
//                }
//            }
//            else
//            {
//                collection_map.Pairs((Link<IAddable<T>, <#= child_index_type #>> link) =>
//                { 
//                    ReversedChildBuilding(parent, link._2, depth, link._1.Stepper, link._1.Count, <# for (int j = 1; j <= i; j++) { #>median_axis<#= j #>, <# } #>initial_count, <# for (int j = 1; j <= i; j++) { #>values<#= j #>, <# } #>allowMultithreading);
//                });
//            }
//
//            int count = 0;
//            foreach (Node node in parent.Children)
//                count += node.Count;
//            return count;
//        }
//
//        int ReversedChildBuilding(Node parent, <#= child_index_type #> child_index, int depth, Stepper<T> additions, int count, <# for (int j = 1; j <= i; j++) { #>int prevmed<#= j #>, <# } #>int initial_count, <# for (int j = 1; j <= i; j++) { #>Get<Axis<#= j #>> values<#= j #>, <# } #>bool allowMultithreading)
//        {
//            Omnitree.Bounds<<#= chain_AxisX #>> child_bounds = DetermineChildBounds(parent, child_index);
//            if (depth >= this._depth_load || count <= this._node_load)
//            {
//                Node new_leaf = new Node(child_bounds, parent, child_index);
//                additions((T value) => { new_leaf.Add(value); });
//                parent[new_leaf.Index] = new_leaf;
//                return new_leaf.Count;
//            }
//            else
//            {
//                Node new_branch = new Node(Omnitree.Vector<<#= chain_AxisX #>>.Default, child_bounds, parent, child_index);
//                parent[new_branch.Index] = new_branch;
//                new_branch.Count = Add(new_branch, depth + 1, child_index, additions, count, <# for (int j = 1; j <= i; j++) { #>prevmed<#= j #>, <# } #>count, <# for (int j = 1; j <= i; j++) { #>values<#= j #>, <# } #>allowMultithreading);
//                return new_branch.Count;
//            }
//        }
//
//        /// <summary>Gets the indeces of the median values at the given position during bulk additions.</summary>
//        private void GetMedianIndexes(int count, <#= child_index_type #> child_index, int depth, <# for (int j = 1; j <= i; j++) { #>int previous<#= j #>, <# } #>out int index1<# for (int j = 2; j <= i; j++) { #>, out int index<#= j #><# } #>)
//        {
//            if (depth == 1)
//            {<# for (int j = 1; j <= i; j++) { #>
//                index<#= j #> = (count - 1) / 2;<# } #>
//                return;
//            }
//
//            int splits = Compute.Power(2, depth);
//            int mid_child_range = count / splits;
//<# for (int j = i; j >= 1; j--) { #>
//            if (child_index >= <#= (2 << (j - 1)) / 2 #>)
//            {
//                index<#= j #> = previous<#= j #> + mid_child_range;
//                child_index -= <#= (2 << (j - 1)) / 2 #>;
//            }
//            else
//            {
//                index<#= j #> = previous<#= j #> - mid_child_range;
//            }
//<# } #>
//        }

		

        #endregion

        #region single

        /// <summary>Adds an item to the tree.</summary>
        /// <param name="addition">The item to be added.</param>
        public void Add(T addition)
        {
            if (this._top.Count == int.MaxValue)
                throw new System.InvalidOperationException("(Count == int.MaxValue) max Omnitree size reached (change ints to longs if you need to).");

            // dynamic tree sizes
            ComputeLoads(this._top.Count);

            Omnitree.Bounds<<#= chain_AxisX #>> bounds = GetBoundings(addition);

            // grow the first branch of the tree
            if (!this._top.PointOfDivision.HasValue && this._top.Count >= this._node_load)
            {
                Node top = this._top;

                // create the new branch from the median values
                this._top = new Node(DetermineMedians(top), Omnitree.Bounds<<#= chain_AxisX #>>.None, null, -1);

                // iterate through the elements and add them to the appropriate children
                for (Node.ValueNode list = top.Head; list != null; list = list.Next)
                    Add(list.Value, this._top, GetBoundings(list.Value), 0);
            }

            this.Add(addition, this._top, bounds, 0);
        }
        
        /// <summary>Recursive version of the add function.</summary>
        /// <param name="addition">The item to be added.</param>
        /// <param name="node">The current node for tree trversal.</param>
        /// <param name="ms">The location of the addition.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private void Add(T addition, Node node, Omnitree.Bounds<<#= chain_AxisX #>> bounds, int depth)
        {
            if (!node.PointOfDivision.HasValue)
            {
                //Leaf leaf = node as Leaf;
                if (depth >= this._depth_load || !(node.Count >= this._node_load))
                {
                    node.Add(addition);
                    return;
                }
                else
                {
                    //Node parent = node.Parent;
                    //<#= child_index_type #> child_index = this.DetermineChildIndex(parent.PointOfDivision, location);
                    //Node growth = new Node(DetermineMedians(leaf), leaf.Bounds, parent, child_index);
                    //parent[child_index] = growth;

					Node growth = new Node(DetermineMedians(node), node.Bounds, node.Parent, node.Index);
                    node.Parent[node.Index] = growth;

                    for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                    {
                        Omnitree.Bounds<<#= chain_AxisX #>> temp_bounds = GetBoundings(list.Value);
                        if (EncapsulationCheck(growth.Bounds, temp_bounds))
                            Add(list.Value, growth, temp_bounds, depth);
                        else
                        {
                            ReduceParentCounts(node.Parent, 1);
                            Add(list.Value, this._top, temp_bounds, depth);
                        }
                    }

                    Add(addition, growth, bounds, depth);
                    return;
                }
            }
            else
            {
                //Node branch = node as Node;
                <#= child_index_type #> child_index = this.DetermineChildIndex(node.PointOfDivision.Value, bounds); // determine the child "index" (0 through 2^Dimensions) the addition belongs in
                
				// if -1, then the bounds of the addition straddle the point of division (keep it in current node)
				if (child_index == -1)
				{
					node.Add(addition);
                    return;
				}
				
				Node child_node = node[child_index];

                // null children in branches are just empty leaves
                if (child_node == null)
                {
                    Node new_node = new Node(DetermineChildBounds(node, child_index), node, child_index);
                    node[child_index] = new_node;
                    new_node.Add(addition);
                }
                else
                    // child exists already, continue adding
                    Add(addition, child_node, bounds, depth + 1);

                node.Count++;
                return;
            }
        }

        /// <summary>Determins the dimensions of the child at the given index.</summary>
        /// <param name="leaf">The parent of the node to compute dimensions for.</param>
        /// <param name="child">The index of the child to compute dimensions for.</param>
        /// <param name="median1">The computed minimum dimensions of the child node along the 1D axis.</param>
        /// <param name="median2">The computed minimum dimensions of the child node along the 2D axis.</param>
        /// <param name="median3">The computed minimum dimensions of the child node along the 3D axis.</param>
        private Omnitree.Vector<<#= chain_AxisX #>> DetermineMedians(Node node)
        {
            try
            {
                // extract the values<# for (int j = 1; j <= i; j++) { #>
                Omnitree.Bound<Axis<#= j #>>[] values<#= j #> = new Omnitree.Bound<Axis<#= j #>>[node.Count * 2];<# } #>
                Node.ValueNode for_current = node.Head; // used in for loop
                for (int i = 0; i < node.Count; i++, for_current = for_current.Next)
                    this._getBounds(for_current.Value, 
					out values1[i * 2], out values1[i * 2 + 1]<# for (int j = 2; j <= i; j++) { #>, 
					out values<#= j #>[i * 2], out values<#= j #>[i * 2 + 1]<# } #>);
                return new Omnitree.Vector<<#= chain_AxisX #>>(
					Omnitree.SubDivide(values1, this._defaultCompare1 ? Compare.Default : this._compare1)<# for (int j = 2; j <= i; j++) { #>, 
					Omnitree.SubDivide(values<#= j #>, this._defaultCompare<#= j #> ? Compare.Default : this._compare<#= j #>)<# } #>);
            }
            catch
            {
                // extract the values<# for (int j = 1; j <= i; j++) { #>
                IndexedBigArray<Omnitree.Bound<Axis<#= j #>>> values<#= j #> = new IndexedBigArray<Omnitree.Bound<Axis<#= j #>>>(node.Count * 2);<# } #>
                Node.ValueNode for_current = node.Head; // used in for loop
                for (int i = 0; i < node.Count; i++, for_current = for_current.Next)
                {<# for (int j = 1; j <= i; j++) { #>
                    Omnitree.Bound<Axis<#= j #>> min<#= j #>; Omnitree.Bound<Axis<#= j #>> max<#= j #>;<# } #>
                    this._getBounds(for_current.Value,
						out min1, out max1<# for (int j = 2; j <= i; j++) { #>,
						out min<#= j #>, out max<#= j #><# } #>);<# for (int j = 1; j <= i; j++) { #>
                    values<#= j #>[i * 2] = min<#= j #>; values<#= j #>[i * 2 + 1] = max<#= j #>;<# } #>
                }
				return new Omnitree.Vector<<#= chain_AxisX #>>(
					Omnitree.SubDivide(values1, this._defaultCompare1 ? Compare.Default : this._compare1)<# for (int j = 2; j <= i; j++) { #>, 
					Omnitree.SubDivide(values<#= j #>, this._defaultCompare<#= j #> ? Compare.Default : this._compare<#= j #>)<# } #>);
            }
        }

        #endregion

        #region Add Helpers

        private Omnitree.Bounds<<#= chain_AxisX #>> DetermineChildBounds(Node node, <#= child_index_type #> child_index)
        {
			// the node parameter should always have a point of division value for this function
			Omnitree.Vector<<#= chain_AxisX #>> pointOfDivision = node.PointOfDivision.Value;
<# for (int j = i; j >= 1; j--) { #>
            Omnitree.Bound<Axis<#= j #>> min<#= j #>, max<#= j #>;
            if (child_index >= <#= (2 << (j - 1)) / 2 #>)
            {
                min<#= j #> = pointOfDivision.Axis<#= j #>;
                max<#= j #> = node.Bounds.Max<#= j #>;
                child_index -= <#= (2 << (j - 1)) / 2 #>;
            }
            else
            {
                min<#= j #> = node.Bounds.Min<#= j #>;
                max<#= j #> = pointOfDivision.Axis<#= j #>;
            }
<# } #>
            return new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>);
        }

        #endregion

        #endregion

        #region Clear

        /// <summary>Returns the tree to an empty state.</summary>
        public void Clear()
        {
            this._top = new Node(Omnitree.Bounds<<#= chain_AxisX #>>.None, null, -1);
            ComputeLoads(0);
        }

        #endregion

        #region Clone

        /// <summary>Creates a shallow clone of this data structure.</summary>
        /// <returns>A shallow clone of this data structure.</returns>
        public OmnitreeBoundsLinked<T, <#= chain_AxisX #>> Clone()
        {
            return new OmnitreeBoundsLinked<T, <#= chain_AxisX #>>(this);
        }

        #endregion

        #region Count

        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceEncapsulated(<#= chain_AxisX_minX_AxisX_maxX #>)
        {
            return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>));
        }
        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceEncapsulated(<#= chain_BoundAxisX_minX_BoundAxisX_maxX #>)
        {
            return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>));
        }
        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        <#= documentation_AxisX_axisX #>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceEncapsulated(<#= chain_AxisX_axisX #>)
        {
            return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_axisX_axisX #>));
        }
        /// <summary>Counts the number of items encapsulated by a sub space.</summary>
        <#= documentation_AxisX_axisX #>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceEncapsulated(<#= chain_BoundAxisX_axisX #>)
        {
            return CountSubSpaceEncapsulated(_top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_axisX_axisX #>));
        }

        /// <summary>Counts the number of items overlapped by a sub space.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceOverlapped(<#= chain_AxisX_minX_AxisX_maxX #>)
        {
            return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>));
        }
        /// <summary>Counts the number of items overlapped by a sub space.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceOverlapped(<#= chain_BoundAxisX_minX_BoundAxisX_maxX #>)
        {
            return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>));
        }
        /// <summary>Counts the number of items overlapped by a sub space.</summary>
        <#= documentation_AxisX_axisX #>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceOverlapped(<#= chain_AxisX_axisX #>)
        {
            return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_axisX_axisX #>));
        }
        /// <summary>Counts the number of items overlapped by a sub space.</summary>
        <#= documentation_AxisX_axisX #>
        /// <returns>The number of items in the provided sub space.</returns>
        public int CountSubSpaceOverlapped(<#= chain_BoundAxisX_axisX #>)
        {
            return CountSubSpaceOverlapped(_top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_axisX_axisX #>));
        }

		private int CountSubSpaceEncapsulated(Node node, Omnitree.Bounds<<#= chain_AxisX #>> bounds)
		{
			return CountSubSpaceBase(_top, bounds, (a, b) => EncapsulationCheck(a, b));
		}

		private int CountSubSpaceOverlapped(Node node, Omnitree.Bounds<<#= chain_AxisX #>> bounds)
		{
			return CountSubSpaceBase(_top, bounds, (a, b) => InclusionCheck(a, b));
		}

		private int CountSubSpaceBase(
			Node node,
			Omnitree.Bounds<<#= chain_AxisX #>> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<<#= chain_AxisX #>>, Omnitree.Bounds<<#= chain_AxisX #>>> spatialCheck)
        {
            // adjust min/max values
            int count = 0;
            if (EncapsulationCheck(bounds, node.Bounds))
                count += node.Count;
            else if (!node.PointOfDivision.HasValue)
            {
                for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                    if (spatialCheck(bounds, GetBoundings(list.Value)))
                        count++;
            }
            else
            {
                Node branch = node as Node;
                if (!StraddlesLines(branch.Bounds, branch.PointOfDivision.Value))
                {
                    <#= child_index_type #> child_index = DetermineChildIndex(branch.PointOfDivision.Value, bounds);
                    Node child = branch[child_index];
                    if (child != null)
                      count += this.CountSubSpaceBase(child, bounds, spatialCheck);
                }
                else
                {
                    foreach (Node child in node.Children)
                        count += this.CountSubSpaceBase(child, bounds, spatialCheck);
                }
            }
            return count;
        }

        #endregion

        #region Update

        /// <summary>Iterates through the entire tree and ensures each item is in the proper leaf.</summary>
        public void Update()
        {
            this.Update(this._top, 0);
        }

        /// <summary>Recursive version of the Update method.</summary>
        /// <param name="node">The current node of iteration.</param>
        /// <param name="depth">The current depth of iteration.</param>
        private int Update(Node node, int depth)
        {
			// I messed up this function in the conversion
			throw new System.NotImplementedException();

            int removals = 0;

            if (!node.PointOfDivision.HasValue)
            {
                Node.ValueNode current = node.Head;
                Node.ValueNode previous = null;
                while (current != null)
                {
                    Omnitree.Bounds<<#= chain_AxisX #>> bounds = GetBoundings(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, bounds))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            node.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;

                        Node whereToAdd = GetEncapsulationParent(node.Parent, bounds);

                        if (whereToAdd == null)
                            throw new System.Exception("an item was updated outside the range of the omnitree");

                        this.Add(updated, whereToAdd, bounds, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                node.Count -= removals;
                return removals;
            }
            else
            {
                Node branch = node as Node;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        public void Update(<#= chain_AxisX_minX_AxisX_maxX #>)
        {
            this.Update(new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        public void Update(<#= chain_BoundAxisX_minX_BoundAxisX_maxX #>)
        {
            this.Update(new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        <#= documentation_AxisX_axisX #>
        public void Update(<#= chain_AxisX_axisX #>)
        {
            this.Update(new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_axisX_axisX #>), this._top, 0);
        }
        /// <summary>Iterates through the provided dimensions and ensures each item is in the proper leaf.</summary>
        <#= documentation_AxisX_axisX #>
        public void Update(<#= chain_BoundAxisX_axisX #>)
        {
            this.Update(new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_axisX_axisX #>), this._top, 0);
        }
        private int Update(Omnitree.Bounds<<#= chain_AxisX #>> bounds, Node node, int depth)
        {
			// I messed up this function in the conversion
			throw new System.NotImplementedException();

            if (!InclusionCheck(bounds, node.Bounds))
                return 0;

            int removals = 0;

            if (!node.PointOfDivision.HasValue)
            {
                Node.ValueNode current = node.Head;
                Node.ValueNode previous = null;
                while (current != null)
                {
                    Omnitree.Bounds<<#= chain_AxisX #>> item_bounds = GetBoundings(current.Value);
                    if (!this.EncapsulationCheck(node.Bounds, item_bounds))
                    {
                        removals++;
                        T updated = current.Value;
                        if (previous == null)
                        {
                            node.Head = current.Next;
                            goto HeadRemoved;
                        }
                        else
                            previous.Next = current.Next;
                        Node whereToAdd = GetEncapsulationParent(node.Parent, item_bounds);
                        if (whereToAdd == null)
                            throw new System.Exception("an item was updates outside the range of the omnitree");
                        this.Add(updated, whereToAdd, item_bounds, whereToAdd.Depth);
                    }
                    previous = current;
                HeadRemoved:
                    current = current.Next;
                }
                node.Count -= removals;
                return removals;
            }
            else
            {
                Node branch = node as Node;
                int skipped = 0;
                for (int i = 0; i + skipped < branch.Children.Length; )
                {
                    removals += this.Update(branch.Children[i], depth + 1);
                    if (branch.Children[i].Count == 0)
                        branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];
                    else
                        i++;
                }
                Node[] newArray = new Node[branch.Children.Length - skipped];
                Array.Copy(branch.Children, newArray, newArray.Length);
                branch.Children = newArray;

                branch.Count -= removals;

                if (branch.Count < this._depth_load && branch.Count != 0)
                    ShrinkChild(branch.Parent, branch.Index);
            }

            return removals;
        }

        #endregion

        #region Remove

        /// <summary>Removes all the items qualified by the delegate.</summary>
        /// <param name="where">The predicate to qualify removals.</param>
        public void Remove(Predicate<T> where)
        {
            this.Remove(this._top, where);
            ComputeLoads(this._top.Count);
        }

        /// <summary>Recursive version of the remove method.</summary>
        /// <param name="node">The current node of traversal.</param>
        /// <param name="where">The predicate to qualify removals.</param>
        private int Remove(Node node, Predicate<T> where)
        {
            int removals = 0;

			// items
            while (node.Head != null && where(node.Head.Value))
            {
                node.Head = node.Head.Next;
                removals++;
            }
            if (node.Head != null)
            {
                Node.ValueNode list = node.Head;
                while (list.Next != null)
                {
                    if (where(list.Next.Value))
                    {
                        list.Next = list.Next.Next;
                        removals++;
                    }
                }
            }
            node.Count -= removals;
            
			// children
			if (node.Children != null)
			{
				int skipped = 0;
				for (int i = 0; i + skipped < node.Children.Length; )
				{
				    removals += this.Remove(node.Children[i], where);
				    if (node.Children[i].Count == 0)
				        node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
				    else
				        i++;
				}
				Node[] newArray = new Node[node.Children.Length - skipped];
				Array.Copy(node.Children, newArray, newArray.Length);
				node.Children = newArray;

				node.Count -= removals;

				if (node.Count < this._depth_load && node.Count != 0)
				    ShrinkChild(node.Parent, node.Index);
			}
            return removals;
        }

        /// <summary>Removes all the items encapsulated in a given space.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveEncapsulated(<#= chain_AxisX_minX_AxisX_maxX #>)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>));
        }
        /// <summary>Removes all the items encapsulated in a given space.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveEncapsulated(<#= chain_BoundAxisX_minX_BoundAxisX_maxX #>)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>));
        }
        /// <summary>Removes all the items encapsulated in a given space.</summary>
        <#= documentation_AxisX_axisX #>
        public void RemoveEncapsulated(<#= chain_BoundAxisX_axisX #>)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_axisX_axisX #>));
        }
        private int RemoveEncapsulated(Node node, Omnitree.Bounds<<#= chain_AxisX #>> bounds)
        {
            int removals = this.RemoveBase(node, bounds, (a, b) => this.EncapsulationCheck(a, b));
			ComputeLoads(this._top.Count);
			return removals;
        }

		/// <summary>Removes all the items overlapping a given space.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveOverlapped(<#= chain_AxisX_minX_AxisX_maxX #>)
        {
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>));
        }
        /// <summary>Removes all the items overlapping a given space.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveOverlapped(<#= chain_BoundAxisX_minX_BoundAxisX_maxX #>)
        {
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>));
        }
        private int RemoveOverlapped(Node node, Omnitree.Bounds<<#= chain_AxisX #>> bounds)
        {
            int removals = this.RemoveBase(node, bounds, (a, b) => this.InclusionCheck(a, b));
			ComputeLoads(this._top.Count);
			return removals;
        }

		private int RemoveBase(
			Node node,
			Omnitree.Bounds<<#= chain_AxisX #>> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<<#= chain_AxisX #>>, Omnitree.Bounds<<#= chain_AxisX #>>> spatialCheck)
        {
            int removals = 0;
            if (InclusionCheck(bounds, node.Bounds))
            {
				// items
                Node.ValueNode current_node = node.Head;
                Node.ValueNode previous_node = null;
                while (current_node != null)
                {
                    Node.ValueNode temp_previous = current_node;
                    if (spatialCheck(bounds, GetBoundings(current_node.Value)))
                    {
                        removals++;
                        if (current_node == node.Head)
                            node.Head = node.Head.Next;
                        else
                        {
                            previous_node.Next = current_node.Next;
                            temp_previous = previous_node;
                        }
                    }
                    previous_node = temp_previous;
                    current_node = current_node.Next;
                }
                node.Count -= removals;
                
				// children
				if (node.Children != null)
				{
					int skipped = 0;
					for (int i = 0; i + skipped < node.Children.Length; )
					{
					    removals += this.RemoveBase(node.Children[i], bounds, spatialCheck);
					    if (node.Children[i].Count == 0)
					        node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
					    else
					        i++;
					}
					Node[] newArray = new Node[node.Children.Length - skipped];
					Array.Copy(node.Children, newArray, newArray.Length);
					node.Children = newArray;

					node.Count -= removals;
					// convert this branch back into a leaf
					// Note: if count is zero, it will be chopped off
					if (node.Count < this._depth_load && node.Count > 0)
					    ShrinkChild(node.Parent, node.Index);
				}
            }
			
            return removals;
        }

		/// <summary>Removes all the items in a given space validated by a predicate.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveEncapsulated(<#= chain_AxisX_minX_AxisX_maxX #>, Predicate<T> where)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>), where);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveEncapsulated(<#= chain_BoundAxisX_minX_BoundAxisX_maxX #>, Predicate<T> where)
        {
            this.RemoveEncapsulated(this._top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>), where);
        }
        private int RemoveEncapsulated(Node node, Omnitree.Bounds<<#= chain_AxisX #>> bounds, Predicate<T> where)
        {
            int removals = RemoveBase(node, bounds, where, (a, b) => this.EncapsulationCheck(a, b));
			ComputeLoads(this._top.Count);
			return removals;
        }

        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveOverlapped(<#= chain_AxisX_minX_AxisX_maxX #>, Predicate<T> where)
        {
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>), where);
        }
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveOverlapped(<#= chain_BoundAxisX_minX_BoundAxisX_maxX #>, Predicate<T> where)
        {
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>), where);
        }
        private int RemoveOverlapped(Node node, Omnitree.Bounds<<#= chain_AxisX #>> bounds, Predicate<T> where)
        {
            int removals = RemoveBase(node, bounds, where, (a, b) => this.InclusionCheck(a, b));
			ComputeLoads(this._top.Count);
			return removals;
        }

		private int RemoveBase(
			Node node,
			Omnitree.Bounds<<#= chain_AxisX #>> bounds,
			Predicate<T> where,
			Omnitree.SpatialCheck<Omnitree.Bounds<<#= chain_AxisX #>>, Omnitree.Bounds<<#= chain_AxisX #>>> spatialCheck)
        {
            if (!InclusionCheck(node.Bounds, bounds))
                return 0;
            int removals = 0;
            
			// items
            Node.ValueNode current = node.Head;
            Node.ValueNode previous = null;
            while (current != null)
            {
                if (spatialCheck(bounds, GetBoundings(current.Value)) && where(current.Value))
                {
                    removals++;
                    if (previous == null)
                    {
                        node.Head = current.Next;
                        goto HeadRemoved;
                    }
                    else
                        previous.Next = current.Next;
                }
                previous = current;
            HeadRemoved:
                current = current.Next;
            }
            node.Count -= removals;

            // children
			if (node.Children != null)
			{
				int skipped = 0;
				for (int i = 0; i + skipped < node.Children.Length; )
				{
				    removals += this.RemoveBase(node.Children[i], bounds, where, spatialCheck);
				    if (node.Children[i].Count == 0)
				        node.Children[i] = node.Children[node.Children.Length - skipped++ - 1];
				    else
				        i++;
				}
				Node[] newArray = new Node[node.Children.Length - skipped];
				Array.Copy(node.Children, newArray, newArray.Length);
				node.Children = newArray;

				node.Count -= removals;

				if (node.Count < this._depth_load && node.Count != 0)
				    ShrinkChild(node.Parent, node.Index);
			}
            return removals;
        }

        /// <summary>Removes all instances of a given value.</summary>
        public void Remove(T removal)
        {<# for (int j = 1; j <= i; j++) { #>
            Omnitree.Bound<Axis<#= j #>> min<#= j #>; Omnitree.Bound<Axis<#= j #>> max<#= j #>;<# } #>
            this._getBounds(removal, out min1, out max1<# for (int j = 2; j <= i; j++) { #>, out min<#= j #>, out max<#= j #><# } #>);
            this.RemoveOverlapped(this._top, new Omnitree.Bounds<<#= chain_AxisX #>>(min1, max1<# for (int j = 2; j <= i; j++) { #>, min<#= j #>, max<#= j #><# } #>), item => this._equate(item, removal));
        }
        /// <summary>Removes all the items in a given space.</summary>
        <#= documentation_axisX #>
        /// <returns>The number of items that were removed.</returns>
        public void RemoveOverlapped(Axis1 axis1<# for (int j = 2; j <= i; j++) { #>, Axis<#= j #> axis<#= j #><# } #>)
        {
            this.RemoveOverlapped(axis1, axis1<# for (int j = 2; j <= i; j++) { #>, axis<#= j #>, axis<#= j #><# } #>);
            ComputeLoads(this._top.Count);
        }
        
        /// <summary>Removes all the items in a given space validated by a predicate.</summary>
        <#= documentation_axisX #>
        /// <param name="where">The equality constraint of the removal.</param>
        public void RemoveOverlapped(<#= chain_AxisX_axisX #>, Predicate<T> where)
        {
			this.RemoveOverlapped(axis1, axis1<# for (int j = 2; j <= i; j++) { #>, axis<#= j #>, axis<#= j #><# } #>, where);
            ComputeLoads(this._top.Count);
        }

        #endregion

        #region Stepper And IEnumerable

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public void Stepper(Step<T> function)
        {
            this.Stepper(function, this._top);
        }
        private void Stepper(Step<T> function, Node node)
        {
            Node.ValueNode list = node.Head;
            while (list != null)
            {
                function(list.Value);
                list = list.Next;
            }
			if (node.Children != null)
				foreach (Node child in node.Children)
				    this.Stepper(function, child);
        }

        /// <summary>Traverses every item in the tree and performs the delegate in them.</summary>
        /// <param name="function">The delegate to perform on every item in the tree.</param>
        public StepStatus Stepper(StepBreak<T> function)
        {
            return Stepper(function, _top);
        }
        private StepStatus Stepper(StepBreak<T> function, Node node)
        {
            StepStatus status = StepStatus.Continue;
            
            for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                if (Code.ReturnAssign(ref status, function(list._value)) != StepStatus.Continue)
                    break;
            
			if (node.Children != null)
				foreach (Node child in node.Children)
				    if (Code.ReturnAssign(ref status, Stepper(function, child)) != StepStatus.Continue)
				        break;
            
            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        public void StepperEncapsulated(Step<T> function, <#= chain_AxisX_minX_AxisX_maxX #>)
        {
            StepperEncapsulated(function, _top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        public void StepperEncapsulated(Step<T> function, <#= chain_BoundAxisX_minX_BoundAxisX_maxX #>)
        {
            StepperEncapsulated(function, _top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>));
        }
        private void StepperEncapsulated(Step<T> function, Node node, Omnitree.Bounds<<#= chain_AxisX #>> bounds)
        {
            StepperBase(function, node, bounds, (a, b) => this.EncapsulationCheck(a, b));
        }

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        public void StepperOverlapped(Step<T> function, <#= chain_AxisX_minX_AxisX_maxX #>)
        {
            StepperOverlapped(function, _top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        public void StepperOverlapped(Step<T> function, <#= chain_BoundAxisX_minX_BoundAxisX_maxX #>)
        {
            StepperOverlapped(function, _top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>));
        }
        private void StepperOverlapped(Step<T> function, Node node, Omnitree.Bounds<<#= chain_AxisX #>> bounds)
        {
            StepperBase(function, node, bounds, (a, b) => this.InclusionCheck(a, b));
        }

		private void StepperBase(
			Step<T> function,
			Node node,
			Omnitree.Bounds<<#= chain_AxisX #>> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<<#= chain_AxisX #>>, Omnitree.Bounds<<#= chain_AxisX #>>> spatialCheck)
        {
            for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                if (spatialCheck(bounds, GetBoundings(list.Value)))
                    function(list.Value);

			if (node.Children != null)
			{
				foreach (Node child in node.Children)
				    // optimization: stop bounds checking if space encapsulates node
				    if (EncapsulationCheck(bounds, child.Bounds))
				        this.Stepper(function, child);
				    else if (InclusionCheck(child.Bounds, bounds))
				        this.StepperBase(function, child, bounds, spatialCheck);
			}
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        public StepStatus StepperEncapsulated(StepBreak<T> function, <#= chain_AxisX_minX_AxisX_maxX #>)
        {
            return StepperEncapsulated(function, _top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        public StepStatus StepperEncapsulated(StepBreak<T> function, <#= chain_BoundAxisX_minX_BoundAxisX_maxX #>)
        {
			return StepperEncapsulated(function, _top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>));
        }
        private StepStatus StepperEncapsulated(StepBreak<T> function, Node node, Omnitree.Bounds<<#= chain_AxisX #>> bounds)
        {
            return StepperBase(function, node, bounds, (a, b) => this.EncapsulationCheck(a, b));
        }

		/// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        public StepStatus StepperOverlapped(StepBreak<T> function, <#= chain_AxisX_minX_AxisX_maxX #>)
        {
            return StepperOverlapped(function, _top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>));
        }
        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        <#= documentation_AxisX_minX_AxisX_maxX #>
        public StepStatus StepperOverlapped(StepBreak<T> function, <#= chain_BoundAxisX_minX_BoundAxisX_maxX #>)
        {
			return StepperOverlapped(function, _top, new Omnitree.Bounds<<#= chain_AxisX #>>(<#= chain_minX_maxX #>));
        }
        private StepStatus StepperOverlapped(StepBreak<T> function, Node node, Omnitree.Bounds<<#= chain_AxisX #>> bounds)
        {
            return StepperBase(function, node, bounds, (a, b) => this.InclusionCheck(a, b));
        }

		private StepStatus StepperBase(
			StepBreak<T> function,
			Node node,
			Omnitree.Bounds<<#= chain_AxisX #>> bounds,
			Omnitree.SpatialCheck<Omnitree.Bounds<<#= chain_AxisX #>>, Omnitree.Bounds<<#= chain_AxisX #>>> spatialCheck)
        {
            StepStatus status = StepStatus.Continue;

            for (Node.ValueNode list = node.Head; list != null; list = list.Next)
                if (spatialCheck(bounds, GetBoundings(list.Value)) &&
                    Code.ReturnAssign(ref status, function(list.Value)) != StepStatus.Continue)
                    break;

			if (node.Children != null)
			{
				foreach (Node child in node.Children)
				    // optimization: stop bounds checking if space encapsulates node
				    if (EncapsulationCheck(bounds, child.Bounds) &&
				        Code.ReturnAssign(ref status, this.Stepper(function, child)) != StepStatus.Continue)
				        break;
				    else if (!InclusionCheck(child.Bounds, bounds) &&
				        Code.ReturnAssign(ref status, this.StepperBase(function, child, bounds, spatialCheck)) != StepStatus.Continue)
				        break;
			}

            return status;
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        <#= documentation_axisX #>
        public void StepperOverlapped(Step<T> function, <#= chain_AxisX_axisX #>)
        {
            StepperOverlapped(function, this._top, new Omnitree.Bounds<<#= chain_AxisX #>>(axis1, axis1<# for (int j = 2; j <= i; j++) { #>, axis<#= j #>, axis<#= j #><# } #>));
        }

        /// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
        /// <param name="function">The delegate to perform on all items in the tree within the given bounds.</param>
        <#= documentation_axisX #>
        public StepStatus StepperOverlapped(StepBreak<T> function, <#= chain_AxisX_axisX #>)
        {
			return StepperOverlapped(function, this._top, new Omnitree.Bounds<<#= chain_AxisX #>>(axis1, axis1<# for (int j = 2; j <= i; j++) { #>, axis<#= j #>, axis<#= j #><# } #>));
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        /// <summary>FOR COMPATIBILITY ONLY. AVOID IF POSSIBLE.</summary>
        System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
        {
            throw new System.NotImplementedException();
            //return (this.ToArray() as System.Collections.Generic.IEnumerable<T>).GetEnumerator();
        }

        #endregion

        #region Helpers

        private bool StraddlesLines(Omnitree.Bounds<<#= chain_AxisX #>> bounds, Omnitree.Vector<<#= chain_AxisX #>> vector)
        {<# for (int j = 1; j <= i; j++) { #>
			if ((!bounds.Min<#= j #>.Exists || (this._compare<#= j #>(bounds.Min<#= j #>.Value, vector.Axis<#= j #>) != Comparison.Greater)) &&
				(!bounds.Max<#= j #>.Exists || (this._compare<#= j #>(bounds.Max<#= j #>.Value, vector.Axis<#= j #>) != Comparison.Less)))
				return true;<# } #>
            return false;
        }

        /// <summary>Computes the child index that contains the desired dimensions.</summary>
        /// <param name="node">The branch .</param>
        /// <param name="vector">The dimensions to determine the child index.</param>
        /// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>
        private <#= child_index_type #> DetermineChildIndex(Omnitree.Vector<<#= chain_AxisX #>> pointOfDivision, Omnitree.Bounds<<#= chain_AxisX #>> bounds)
        {
			// make sure a child encapsulates the bounds (otherwise the bounds cannot move down the tree)
			if (StraddlesLines(bounds, pointOfDivision))
				return -1;

            <#= child_index_type #> child = 0;<# for (int j = 1; j <= i; j++) { #>
            if (!bounds.Min<#= j #>.Exists || !(this._compare<#= j #>(bounds.Min<#= j #>.Value, pointOfDivision.Axis<#= j #>) == Comparison.Less))
                child += 1 << <#= j - 1 #>;<# } #>
            return child;
        }

        /// <summary>Converts a branch back into a leaf when the count is reduced.</summary>
        /// <param name="parent">The parent to shrink a child of.</param>
        /// <param name="child">The index of the child to shrink.</param>
        private void ShrinkChild(Node parent, <#= child_index_type #> child_index)
        {
            Node leaf;
            Node removal = null;
            if (parent == null) // top of tree
            {
                removal = this._top;
                leaf = new Node(Omnitree.Bounds<<#= chain_AxisX #>>.None, null, -1);
                this._top = leaf;
            }
            else // non-top branch
            {
                removal = parent[child_index];
                leaf = new Node(removal.Bounds, removal.Parent, removal.Index);
                parent[child_index] = leaf;
            }

            this.Stepper((T step) => { leaf.Add(step); }, removal);
        }

        /// <summary>Reduces the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the reduction.</param>
        /// <param name="reduction">The amount to reduce the parent counts by.</param>
        private void ReduceParentCounts(Node parent, int reduction)
        {
            IncreaseParentCounts(parent, -reduction);
        }

        /// <summary>Increases the counts of all the parents of a given node by a given amount.</summary>
        /// <param name="parent">The starting parent of the increase.</param>
        /// <param name="increase">The amount to increase the parent counts by.</param>
        private void IncreaseParentCounts(Node parent, int increase)
        {
            Node looper = parent;
            while (looper != null)
            {
                looper.Count += increase;
                looper = looper.Parent;
            }
        }

        /// <summary>Checks a node for inclusion (overlap) between two bounds.</summary>
        /// <returns>True if the spaces overlap; False if not.</returns>
        private bool InclusionCheck(Omnitree.Bounds<<#= chain_AxisX #>> a, Omnitree.Bounds<<#= chain_AxisX #>> b)
        {
<# for (int j = 1; j <= i; j++) { #>
            if (a.Max<#= j #>.Exists && b.Min<#= j #>.Exists && this._compare<#= j #>(a.Max<#= j #>.Value, b.Min<#= j #>.Value) == Comparison.Less)
                return false;
            else if (a.Min<#= j #>.Exists && b.Max<#= j #>.Exists && this._compare<#= j #>(a.Min<#= j #>.Value, b.Max<#= j #>.Value) == Comparison.Greater)
                return false;
<# } #>
            return true;
        }

        /// <summary>Checks if a space encapsulates a point.</summary>
        /// <returns>True if the space encapsulates the point; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<<#= chain_AxisX #>> bounds, Omnitree.Vector<<#= chain_AxisX #>> vector)
        {
            // if the location is not outside the bounds, it must be inside
<# for (int j = 1; j <= i; j++) { #>
            if (bounds.Min<#= j #>.Exists && this._compare<#= j #>(vector.Axis<#= j #>, bounds.Min<#= j #>.Value) == Comparison.Less)
                return false;
            else if (bounds.Max<#= j #>.Exists && this._compare<#= j #>(vector.Axis<#= j #>, bounds.Max<#= j #>.Value) == Comparison.Greater)
                return false;
<# } #>
            return true;
        }

        /// <summary>Checks if a space (left) encapsulates another space (right).</summary>
        /// <returns>True if the left space encapsulates the right; False if not.</returns>
        private bool EncapsulationCheck(Omnitree.Bounds<<#= chain_AxisX #>> a, Omnitree.Bounds<<#= chain_AxisX #>> b)
        {
            if ((a.Min1.Exists && !b.Min1.Exists)<# for (int j = 2; j <= i; j++) { #> || (a.Min<#= j #>.Exists && !b.Min<#= j #>.Exists)<# } #>)
                return false;
			if ((a.Max1.Exists && !b.Max1.Exists)<# for (int j = 2; j <= i; j++) { #> || (a.Max<#= j #>.Exists && !b.Max<#= j #>.Exists)<# } #>)
                return false;
<# for (int j = 1; j <= i; j++) { #>
            if (b.Min<#= j #>.Exists && a.Min<#= j #>.Exists && this._compare<#= j #>(a.Min<#= j #>.Value, b.Min<#= j #>.Value) != Comparison.Less)
                return false;
            if (b.Max<#= j #>.Exists && a.Max<#= j #>.Exists && this._compare<#= j #>(a.Max<#= j #>.Value, b.Max<#= j #>.Value) != Comparison.Greater)
                return false;
<# } #>
            return true;
        }

        /// <summary>Checks for equality between two locations.</summary>
        /// <returns>True if equal; False if not;</returns>
        private bool EqualsCheck(Omnitree.Vector<<#= chain_AxisX #>> a, Omnitree.Vector<<#= chain_AxisX #>> b)
        {
<# for (int j = 1; j <= i; j++) { #>
            if (!this._equate<#= j #>(a.Axis<#= j #>, b.Axis<#= j #>))
                return false;
<# } #>
            return true;
        }

        /// <summary>Gets the nearest parent that encapsulates a location.</summary>
        /// <param name="node">The starting node to find the encapsulating parent of the location.</param>
        /// <param name="bounds">The bounds to get the encapsulating parent from.</param>
        /// <returns>The nearest node that encapsulates the given location.</returns>
        private Node GetEncapsulationParent(Node node, Omnitree.Bounds<<#= chain_AxisX #>> bounds)
        {
            while (node != null && !EncapsulationCheck(node.Bounds, bounds))
                node = node.Parent;
            return node;
        }

        /// <summary>Checks for required load reduction.</summary>
        private void ComputeLoads(int count)
        {
			if (count < _naturalLogLower || count > _naturalLogUpper)
			{
				int naturalLog = (int)Math.Log(count);
				_naturalLogLower = (int)Math.Pow(Math.E, naturalLog);
				_naturalLogUpper = (int)Math.Pow(Math.E, naturalLog + 1);

				_naturalLogLower = Math.Min(count - 10, _naturalLogLower);
				_naturalLogUpper = Math.Max(2, _naturalLogUpper);
				naturalLog = Math.Max(2, naturalLog);

				this._depth_load = Compute.Maximum(naturalLog, _default_depth_load);
				this._node_load = (int)Compute.Maximum(naturalLog, _children_per_node);
			}
        }

        private Omnitree.Bounds<<#= chain_AxisX #>> GetBoundings(T value)
        {<# for (int j = 1; j <= i; j++) { #>
            Omnitree.Bound<Axis<#= j #>> min<#= j #>; Omnitree.Bound<Axis<#= j #>> max<#= j #>;<# } #>
            this._getBounds(value,
				out min1, out max1<# for (int j = 2; j <= i; j++) { #>,
				out min<#= j #>, out max<#= j #><# } #>);
            return new Omnitree.Bounds<<#= chain_AxisX #>>(
				min1, max1<# for (int j = 2; j <= i; j++) { #>,
				min<#= j #>, max<#= j #><# } #>);
        }

        #endregion

        #endregion
    }

    #endregion<# } #>

    #endregion
}