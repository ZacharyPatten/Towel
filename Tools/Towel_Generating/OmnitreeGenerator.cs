using System;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Text;
using Towel;
using static Towel.Statics;

namespace Towel_Generating
{
	public static class OmnitreeGenerator
	{
		public static string Run(int dimensions = Program.DefaultGenerationCount)
		{
			string generatorPath = Path.GetRelativePath(Path.Combine(Path.GetDirectoryName(sourcefilepath())!, "..", ".."), sourcefilepath());

			StringBuilder code = new();
			code.AppendLine($@"//------------------------------------------------------------------------------");
			code.AppendLine($@"// <auto-generated>");
			code.AppendLine($@"// This code was generated from ""{generatorPath}"".");
			code.AppendLine($@"// </auto-generated>");
			code.AppendLine($@"//------------------------------------------------------------------------------");
			code.AppendLine($@"");
			code.AppendLine($@"using System;");
			if (dimensions >= 30)
			{
				code.AppendLine($@"using System.Numerics;");
			}
			code.AppendLine($@"using static Towel.Statics;");
			code.AppendLine($@"using static Towel.DataStructures.Omnitree;");
			code.AppendLine($@"");
			code.AppendLine($@"namespace Towel.DataStructures.TEMP");
			code.AppendLine($@"{{");

			#region Notes

			code.AppendLine($@"	#region Notes");
			code.AppendLine($@"");
			code.AppendLine($@"	// Visualizations--------------------------------------------------");
			code.AppendLine($@"	//");
			code.AppendLine($@"	// 1 Dimensional:");
			code.AppendLine($@"	//");
			code.AppendLine($@"	//  -1D |-----------|-----------| +1D");
			code.AppendLine($@"	//");
			code.AppendLine($@"	//       <--- 0 ---> <--- 1 --->");
			code.AppendLine($@"	//");
			code.AppendLine($@"	// 2 Dimensional:");
			code.AppendLine($@"	//       _____________________");
			code.AppendLine($@"	//      |          |          |  +2D");
			code.AppendLine($@"	//      |          |          |   ^");
			code.AppendLine($@"	//      |     2    |     3    |   |");
			code.AppendLine($@"	//      |          |          |   |");
			code.AppendLine($@"	//      |----------|----------|   |");
			code.AppendLine($@"	//      |          |          |   |");
			code.AppendLine($@"	//      |          |          |   |");
			code.AppendLine($@"	//      |     0    |     1    |   |");
			code.AppendLine($@"	//      |          |          |   v");
			code.AppendLine($@"	//      |__________|__________|  -2D");
			code.AppendLine($@"	//");
			code.AppendLine($@"	//       -1D <-----------> +1D ");
			code.AppendLine($@"	//");
			code.AppendLine($@"	// 3 Dimensional:");
			code.AppendLine($@"	//");
			code.AppendLine($@"	//            +3D     _____________________");
			code.AppendLine($@"	//           7       /         /          /|");
			code.AppendLine($@"	//          /       /    6    /     7    / |");
			code.AppendLine($@"	//         /       /---------/----------/  |");
			code.AppendLine($@"	//        /       /    2    /     3    /|  |");
			code.AppendLine($@"	//       L       /_________/__________/ |  |");
			code.AppendLine($@"	//    -3D       |          |          | | /|          +2D");
			code.AppendLine($@"	//              |          |          | |/ |           ^");
			code.AppendLine($@"	//              |     2    |     3    | /  |           |");
			code.AppendLine($@"	//              |          |          |/|  | <-- 5     |");
			code.AppendLine($@"	//              |----------|----------| |  |           |");
			code.AppendLine($@"	//              |          |          | |  /           |");
			code.AppendLine($@"	//              |          |          | | /            |");
			code.AppendLine($@"	//              |     0    |     1    | |/             |");
			code.AppendLine($@"	//              |          |          | /              v");
			code.AppendLine($@"	//              |__________|__________|/              -2D");
			code.AppendLine($@"	//             ");
			code.AppendLine($@"	//                   ^");
			code.AppendLine($@"	//                   |");
			code.AppendLine($@"	//                   4 (behind 0)");
			code.AppendLine($@"	//");
			code.AppendLine($@"	//               -1D <-----------> +1D");
			code.AppendLine($@"");
			code.AppendLine($@"	#endregion");
			code.AppendLine($@"");

			#endregion

			#region public static partial class Omnitree

			code.AppendLine($@"	/// <summary>Contains the necessary type definitions for the various omnitree types.</summary>");
			code.AppendLine($@"	public static partial class Omnitree");
			code.AppendLine($@"	{{");
			for (int i = 1, I = 2; i <= dimensions; i++, I++)
			{
				code.AppendLine($@"		#region {i} Dimensional");
				code.AppendLine($@"");

				#region public struct Vector<Axis1, Axis2, Axis3...>

				code.AppendLine($@"		/// <summary>Represents a {i}D vector.</summary>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		/// <typeparam name=""A{j}"">The generic type of the {j} dimension.</typeparam>");
				}
				code.AppendLine($@"		public struct Vector<{Join(1..I, n => $"A{n}", ", ")}>");
				code.AppendLine($@"		{{");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			/// <summary>The value along axis {j}.</summary>");
					code.AppendLine($@"			public A{j} Axis{j};");
				}
				code.AppendLine($@"");
				code.AppendLine($@"			/// <summary>A location along each axis.</summary>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			/// <param name=""axis{j}"">The location along axis {j}.</param>");
				}
				code.AppendLine($@"			public Vector({Join(1..I, n => $"A{n} axis{n}", ", ")})");
				code.AppendLine($@"			{{");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"				Axis{j} = axis{j};");
				}
				code.AppendLine($@"			}}");
				code.AppendLine($@"");
				if (i > 1)
				{
					code.AppendLine($@"			/// <summary>Converts a tuple to a vector.</summary>");
					code.AppendLine($@"			/// <param name=""tuple"">The tuple to convert to a vector.</param>");
					code.AppendLine($@"			public static implicit operator Vector<{Join(1..I, n => $"A{n}", ", ")}>(({Join(1..I, n => $"A{n} Axis{n}", ", ")}) tuple) =>");
					code.AppendLine($@"				new({Join(1..I, n => $"tuple.Axis{n}", ", ")});");
				}
				else
				{
					code.AppendLine($@"			/// <summary>Converts a tuple to a vector.</summary>");
					code.AppendLine($@"			/// <param name=""axis1"">The 1D cordinate to convert to a vector.</param>");
					code.AppendLine($@"			public static implicit operator Vector<{Join(1..I, n => $"A{n}", ", ")}>(A1 axis1) =>");
					code.AppendLine($@"				new(axis1);");
				}
				code.AppendLine($@"		}}");
				code.AppendLine($@"");

				#endregion

				#region public struct Bounds<Axis1, Axis2, Axis3...>

				code.AppendLine($@"		/// <summary>Represents a {i}D bounding box.</summary>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		/// <typeparam name=""Axis{j}"">The generic type of the {j} dimension.</typeparam>");
				}
				code.AppendLine($@"		public struct Bounds<{Join(1..I, n => $"Axis{n}", ", ")}>");
				code.AppendLine($@"		{{");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			/// <summary>The minimum value along the {j} dimension.</summary>");
					code.AppendLine($@"			public Bound<Axis{j}> Min{j};");
					code.AppendLine($@"			/// <summary>The maximum value along the {j} dimension.</summary>");
					code.AppendLine($@"			public Bound<Axis{j}> Max{j};");
				}
				code.AppendLine($@"");
				code.AppendLine($@"			/// <summary>Extends infinitely along each axis.</summary>");
				code.AppendLine($@"			public static Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> None =>");
				code.AppendLine($@"				new Bounds<{Join(1..I, n => $"Axis{n}", ", ")}>(");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"					Bound<Axis{j}>.None, Bound<Axis{j}>.None{(j == i ? ");" : ",")}");
				}
				code.AppendLine($@"");
				code.AppendLine($@"			/// <summary>A set of values denoting a range (or lack of range) along each axis.</summary>");
				code.AppendLine($@"			public Bounds(");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"				Bound<Axis{j}> min{j}, Bound<Axis{j}> max{j}{(j == i ? ")" : ",")}");
				}
				code.AppendLine($@"			{{");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"				Min{j} = min{j}; Max{j} = max{j};");
				}
				code.AppendLine($@"			}}");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");

				#endregion

				#region Helper Methods

				code.AppendLine($@"		/// <summary>Checks a node for overlap between two bounds.</summary>");
				code.AppendLine($@"		/// <returns>True if the spaces overlap; False if not.</returns>");
				code.AppendLine($@"		public static bool OverlapCheck<");
				code.AppendLine($@"			{Join(1..I, n => $"Axis{n}", ", ")},");
				code.AppendLine($@"			{Join(1..I, n => $"Compare{n}", ", ")}>(");
				code.AppendLine($@"			Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> a,");
				code.AppendLine($@"			Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> b,");
				code.AppendLine($@"			{Join(1..I, n => $"Compare{n} compare{n} = default", ", ")})");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			where Compare{j} : struct, IFunc<Axis{j}, Axis{j}, CompareResult>{(j == i ? " =>" : "")}");
				}
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			// Axis {j}");
					code.AppendLine($@"			!(a.Max{j}.Exists && b.Min{j}.Exists && compare{j}.Invoke(a.Max{j}.Value, b.Min{j}.Value) is Less) &&");
					code.AppendLine($@"			!(a.Min{j}.Exists && b.Max{j}.Exists && compare{j}.Invoke(a.Min{j}.Value, b.Max{j}.Value) is Greater){(j == i ? ";" : " &&")}");
				}
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Checks if <paramref name=""a""/> contain <paramref name=""b""/>.</summary>");
				code.AppendLine($@"		/// <param name=""a"">The bounds to check if it contains <paramref name=""b""/>.</param>");
				code.AppendLine($@"		/// <param name=""b"">The vector to check if it is contained in <paramref name=""a""/></param>");
				code.AppendLine($@"		/// <returns>True if <paramref name=""a""/> contains <paramref name=""b""/>; False if not.</returns>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		/// <typeparam name=""Axis{j}"">The generic type of the {j}D axis.</typeparam>");
					code.AppendLine($@"		/// <typeparam name=""Compare{j}"">The method for comparing values along the {j}D axis.</typeparam>");
					code.AppendLine($@"		/// <param name=""compare{j}"">The function for comparing values along the {j}D axis.</param>");
				}
				code.AppendLine($@"		public static bool ContainsCheck<");
				code.AppendLine($@"			{Join(1..I, n => $"Axis{n}", ", ")},");
				code.AppendLine($@"			{Join(1..I, n => $"Compare{n}", ", ")}>(");
				code.AppendLine($@"			Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> a,");
				code.AppendLine($@"			Omnitree.Vector<{Join(1..I, n => $"Axis{n}", ", ")}> b,");
				code.AppendLine($@"			{Join(1..I, n => $"Compare{n} compare{n} = default", ", ")})");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			where Compare{j} : struct, IFunc<Axis{j}, Axis{j}, CompareResult>{(j == i ? " =>" : "")}");
				}
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			!(a.Min{j}.Exists && compare{j}.Invoke(b.Axis{j}, a.Min{j}.Value) is Less) &&");
					code.AppendLine($@"			!(a.Max{j}.Exists && compare{j}.Invoke(b.Axis{j}, a.Max{j}.Value) is Greater){(j == i ? ";" : " &&")}");
				}
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Checks if <paramref name=""a""/> contains all of <paramref name=""b""/>.</summary>");
				code.AppendLine($@"		/// <param name=""a"">The bounds to check if it contains all of <paramref name=""b""/>.</param>");
				code.AppendLine($@"		/// <param name=""b"">The bounds to check if it is entirely contained in <paramref name=""a""/></param>");
				code.AppendLine($@"		/// <returns>True if <paramref name=""a""/> contains all of <paramref name=""b""/>; False if not.</returns>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		/// <typeparam name=""Axis{j}"">The generic type of the {j}D axis.</typeparam>");
					code.AppendLine($@"		/// <typeparam name=""Compare{j}"">The method for comparing values along the {j}D axis.</typeparam>");
					code.AppendLine($@"		/// <param name=""compare{j}"">The function for comparing values along the {j}D axis.</param>");
				}
				code.AppendLine($@"		public static bool ContainsCheck<");
				code.AppendLine($@"			{Join(1..I, n => $"Axis{n}", ", ")},");
				code.AppendLine($@"			{Join(1..I, n => $"Compare{n}", ", ")}>(");
				code.AppendLine($@"			Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> a,");
				code.AppendLine($@"			Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> b,");
				code.AppendLine($@"			{Join(1..I, n => $"Compare{n} compare{n} = default", ", ")})");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			where Compare{j} : struct, IFunc<Axis{j}, Axis{j}, CompareResult>{(j == i ? " =>" : "")}");
				}
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			(a.Min{j}.Exists && !b.Min{j}.Exists) && (a.Max{j}.Exists && !b.Max{j}.Exists) &&");
					code.AppendLine($@"			(b.Min{j}.Exists && a.Min{j}.Exists && compare{j}.Invoke(a.Min{j}.Value, b.Min{j}.Value) is not Less) &&");
					code.AppendLine($@"			(b.Max{j}.Exists && a.Max{j}.Exists && compare{j}.Invoke(a.Max{j}.Value, b.Max{j}.Value) is not Greater){(j == i ? ";" : " &&")}");
				}
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Checks if two vectors are equal.</summary>");
				code.AppendLine($@"		/// <param name=""a"">First vector of the equality check.</param>");
				code.AppendLine($@"		/// <param name=""b"">Second vector of the equality check.</param>");
				code.AppendLine($@"		/// <returns>True if the vectors are equal in value; False if not.</returns>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		/// <typeparam name=""Axis{j}"">The generic type of the {j} dimension.</typeparam>");
					code.AppendLine($@"		/// <typeparam name=""Compare{j}"">The method for comparing elements along the {j} dimension.</typeparam>");
					code.AppendLine($@"		/// <param name=""compare{j}"">The method for comparing elements along the {j} dimension.</param>");
				}
				code.AppendLine($@"		public static bool EqualsCheck<{Join(1..I, n => $"Axis{n}", ", ")}, {Join(1..I, n => $"Compare{n}", ", ")}>(");
				code.AppendLine($@"			Omnitree.Vector<{Join(1..I, n => $"Axis{n}", ", ")}> a, Omnitree.Vector<{Join(1..I, n => $"Axis{n}", ", ")}> b, {Join(1..I, n => $"Compare{n} compare{n} = default", ", ")})");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			where Compare{j} : struct, IFunc<Axis{j}, Axis{j}, CompareResult>{(j == i ? " =>" : "")}");
				}
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			compare{j}.Invoke(a.Axis{j}, b.Axis{j}) is Equal{(j == i ? ";" : " &&")}");
				}
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Checks if a bounds straddles a point if the point extended as a plane along each dimension.</summary>");
				code.AppendLine($@"		/// <param name=""a"">The bounds to determine if it straddles the extended point.</param>");
				code.AppendLine($@"		/// <param name=""b"">The point representing an extended plan along each axis.</param>");
				code.AppendLine($@"		/// <returns>True if the extended point was straddled or false if not.</returns>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		/// <typeparam name=""Axis{j}"">The generic type of the {j} dimension.</typeparam>");
					code.AppendLine($@"		/// <typeparam name=""Compare{j}"">The method for comparing elements along the {j} dimension.</typeparam>");
					code.AppendLine($@"		/// <param name=""compare{j}"">The method for comparing elements along the {j} dimension.</param>");
				}
				code.AppendLine($@"		public static bool StraddlesLines<");
				code.AppendLine($@"			{Join(1..I, n => $"Axis{n}", ", ")},");
				code.AppendLine($@"			{Join(1..I, n => $"Compare{n}", ", ")}>(");
				code.AppendLine($@"			Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> a,");
				code.AppendLine($@"			Omnitree.Vector<{Join(1..I, n => $"Axis{n}", ", ")}> b,");
				code.AppendLine($@"			{Join(1..I, n => $"Compare{n} compare{n} = default", ", ")})");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			where Compare{j} : struct, IFunc<Axis{j}, Axis{j}, CompareResult>{(j == i ? " =>" : "")}");
				}
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			(!a.Min{j}.Exists || (a.Min{j}.Exists && compare{j}.Invoke(a.Min{j}.Value, b.Axis{j}) is not Greater)) &&");
					code.AppendLine($@"			(!a.Max{j}.Exists || (a.Max{j}.Exists && compare{j}.Invoke(a.Max{j}.Value, b.Axis{j}) is not Less)){(j == i ? ";" : " ||")}");
				}
				code.AppendLine($@"");

				#endregion

				code.AppendLine($@"		#endregion {i} Dimensional");
				code.AppendLine($@"");
			}
			code.AppendLine($@"	}}");
			code.AppendLine($@"");

			#endregion

			for (int i = 1, I = 2; i <= dimensions; i++, I++)
			{
				code.AppendLine($@"	#region {i} Dimensional");
				code.AppendLine($@"");

				#region public interface IOmnitree<...>

				code.AppendLine($@"	/// <summary>A {i}D SPT data structure.</summary>");
				code.AppendLine($@"	/// <typeparam name=""T"">The type of values stored in this tree.</typeparam>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"	/// <typeparam name=""Axis{j}"">The generic type of the {j}D axis.</typeparam>");
					code.AppendLine($@"	/// <typeparam name=""Compare{j}"">The function this tree is using to compare <typeparamref name=""T""/>'s along the {j}D axis.</typeparam>");
				}
				code.AppendLine($@"	public interface IOmnitree<T,");
				code.AppendLine($@"		{Join(1..I, n => $"Axis{n}", ", ")},");
				code.AppendLine($@"		{Join(1..I, n => $"Compare{n}", ", ")}>");
				code.AppendLine($@"		: IOmnitree<T>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		where Compare{j} : struct, IFunc<Axis{j}, Axis{j}, CompareResult>");
				}
				code.AppendLine($@"	{{");
				code.AppendLine($@"		#region Properties");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>The current maximum depth of this tree.</summary>");
				code.AppendLine($@"		public int MaxDepth {{ get; }}");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>The current number of nodes in this tree.</summary>");
				code.AppendLine($@"		public int NodeCount {{ get; }}");
				code.AppendLine($@"");
				code.AppendLine($@"		#endregion");
				code.AppendLine($@"	}}");
				code.AppendLine($@"");

				#endregion

				#region public interface IOmnitreePoints<...>

				code.AppendLine($@"	#region OmnitreePoints");
				code.AppendLine($@"");
				code.AppendLine($@"	/// <summary>A {i}D SPT data structure.</summary>");
				code.AppendLine($@"	/// <typeparam name=""T"">The type of values stored in this tree.</typeparam>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"	/// <typeparam name=""Axis{j}"">The generic type of the {j}D axis.</typeparam>");
					code.AppendLine($@"	/// <typeparam name=""Locate{j}"">The function this tree is using to locate <typeparamref name=""T""/>'s along the {j}D axis.</typeparam>");
					code.AppendLine($@"	/// <typeparam name=""Compare{j}"">The function this tree is using to compare <typeparamref name=""T""/>'s along the {j}D axis.</typeparam>");
					code.AppendLine($@"	/// <typeparam name=""Subdivide{j}"">The function this tree is using to subdivide <typeparamref name=""T""/>'s along the {j}D axis.</typeparam>");
				}
				code.AppendLine($@"	public interface IOmnitreePoints<T,");
				code.AppendLine($@"		{Join(1..I, n => $"Axis{n}", ", ")},");
				code.AppendLine($@"		{Join(1..I, n => $"Locate{n}", ", ")},");
				code.AppendLine($@"		{Join(1..I, n => $"Compare{n}", ", ")},");
				code.AppendLine($@"		{Join(1..I, n => $"Subdivide{n}", ", ")}>");
				code.AppendLine($@"		: IOmnitree<T,");
				code.AppendLine($@"			{Join(1..I, n => $"Axis{n}", ", ")},");
				code.AppendLine($@"			{Join(1..I, n => $"Compare{n}", ", ")}>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		where Locate{j} : struct, IFunc<T, Axis{j}>");
				}
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		where Compare{j} : struct, IFunc<Axis{j}, Axis{j}, CompareResult>");
				}
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		where Subdivide{j} : struct, IFunc<(int Count, int Depth, System.Collections.Generic.IEnumerable<Axis{j}> Values, (Bound<Axis{j}> Min, Bound<Axis{j}> Max) Bounds), Axis{j}>");
				}
				code.AppendLine($@"	{{");
				code.AppendLine($@"		#region Properties");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>The current number of branches in this tree.</summary>");
				code.AppendLine($@"		public int BranchCount {{ get; }}");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>The current number of leaves in this tree.</summary>");
				code.AppendLine($@"		public int LeafCount {{ get; }}");
				code.AppendLine($@"");
				code.AppendLine($@"		#endregion");
				code.AppendLine($@"");
				code.AppendLine($@"		#region Methods");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Counts the number of values in a sub space of this tree.</summary>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		/// <param name=""min{j}"">The minimum coordinate of the space along the {j}D axis.</param>");
					code.AppendLine($@"		/// <param name=""max{j}"">The maximum coordinate of the space along the {j}D axis.</param>");
				}
				code.AppendLine($@"		/// <returns>The number of values in the sub space of this tree.</returns>");
				code.AppendLine($@"		int CountSubSpace({Join(1..I, n => $"Bound<Axis{n}> min{n}, Bound<Axis{n}> max{n}", ", ")});");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Removes all the values at the given vector.</summary>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		/// <param name=""axis{j}"">The coordinate along the {j}D axis.</param>");
				}
				code.AppendLine($@"		/// <returns>The number of values that were removed.</returns>");
				code.AppendLine($@"		int Remove({Join(1..I, n => $"Axis{n} axis{n}", ", ")});");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Removes all the values at the given space.</summary>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		/// <param name=""min{j}"">The minimum coordinate along the {j}D axis.</param>");
					code.AppendLine($@"		/// <param name=""max{j}"">The maximum coordinate along the {j}D axis.</param>");
				}
				code.AppendLine($@"		/// <returns>The number of values that were removed.</returns>");
				code.AppendLine($@"		int Remove({Join(1..I, n => $"Bound<Axis{n}> min{n}, Bound<Axis{n}> max{n}", ", ")});");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Removes all the values in the given space.</summary>");
				code.AppendLine($@"		/// <typeparam name=""TPredicate"">The type of the predicate function to determine removal.</typeparam>");
				code.AppendLine($@"		/// <param name=""where"">The predicate function to determine removal.</param>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		/// <param name=""min{j}"">The minimum coordinate along the {j}D axis.</param>");
					code.AppendLine($@"		/// <param name=""max{j}"">The maximum coordinate along the {j}D axis.</param>");
				}
				code.AppendLine($@"		/// <returns>The number of values that were removed.</returns>");
				code.AppendLine($@"		int Remove<TPredicate>({Join(1..I, n => $"Bound<Axis{n}> min{n}, Bound<Axis{n}> max{n}", ", ")}, TPredicate where = default)");
				code.AppendLine($@"			where TPredicate : struct, IFunc<T, bool>;");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Removes all the values at the given vector.</summary>");
				code.AppendLine($@"		/// <typeparam name=""TPredicate"">The type of the predicate function to determine removal.</typeparam>");
				code.AppendLine($@"		/// <param name=""where"">The predicate function to determine removal.</param>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		/// <param name=""axis{j}"">The coordinate along the {j}D axis.</param>");
				}
				code.AppendLine($@"		/// <returns>The number of values that were removed.</returns>");
				code.AppendLine($@"		int Remove<TPredicate>({Join(1..I, n => $"Axis{n} axis{n}", ", ")}, TPredicate where = default)");
				code.AppendLine($@"			where TPredicate : struct, IFunc<T, bool>;");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Performs an action on every value in a space.</summary>");
				code.AppendLine($@"		/// <typeparam name=""TStep"">The type of the step function to perform on every value.</typeparam>");
				code.AppendLine($@"		/// <param name=""step"">The step function to perform on every value.</param>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		/// <param name=""min{j}"">The minimum coordinate along the {j}D axis.</param>");
					code.AppendLine($@"		/// <param name=""max{j}"">The maximum coordinate along the {j}D axis.</param>");
				}
				code.AppendLine($@"		/// <returns>The status of the traversal.</returns>");
				code.AppendLine($@"		StepStatus StepperBreak<TStep>({Join(1..I, n => $"Bound<Axis{n}> min{n}, Bound<Axis{n}> max{n}", ", ")}, TStep step = default)");
				code.AppendLine($@"			where TStep : struct, IFunc<T, StepStatus>;");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Traverses the tree and ensures each value is in the proper leaf.</summary>");
				code.AppendLine($@"		void Update();");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Traverses a space and ensures each value is in the proper leaf.</summary>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		/// <param name=""min{j}"">The minimum coordinate along the {j}D axis.</param>");
					code.AppendLine($@"		/// <param name=""max{j}"">The maximum coordinate along the {j}D axis.</param>");
				}
				code.AppendLine($@"		void Update({Join(1..I, n => $"Bound<Axis{n}> min{n}, Bound<Axis{n}> max{n}", ", ")});");
				code.AppendLine($@"");
				code.AppendLine($@"		#endregion");
				code.AppendLine($@"	}}");
				code.AppendLine($@"");

				#endregion

				#region public class OmnitreePointsLinked<...>

				code.AppendLine($@"	/// <summary>A {i}D SPT data structure.</summary>");
				code.AppendLine($@"	/// <typeparam name=""T"">The type of values stored in this tree.</typeparam>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"	/// <typeparam name=""Axis{j}"">The generic type of the {j}D axis.</typeparam>");
					code.AppendLine($@"	/// <typeparam name=""Locate{j}"">The function this tree is using to locate <typeparamref name=""T""/>'s along the {j}D axis.</typeparam>");
					code.AppendLine($@"	/// <typeparam name=""Compare{j}"">The function this tree is using to compare <typeparamref name=""T""/>'s along the {j}D axis.</typeparam>");
					code.AppendLine($@"	/// <typeparam name=""Subdivide{j}"">The function this tree is using to subdivide <typeparamref name=""T""/>'s along the {j}D axis.</typeparam>");
				}
				code.AppendLine($@"	public class OmnitreePointsLinked<T,");
				code.AppendLine($@"		{Join(1..I, n => $"Axis{n}", ", ")},");
				code.AppendLine($@"		{Join(1..I, n => $"Locate{n}", ", ")},");
				code.AppendLine($@"		{Join(1..I, n => $"Compare{n}", ", ")},");
				code.AppendLine($@"		{Join(1..I, n => $"Subdivide{n}", ", ")}>");
				code.AppendLine($@"		: IOmnitreePoints<T,");
				code.AppendLine($@"			{Join(1..I, n => $"Axis{n}", ", ")},");
				code.AppendLine($@"			{Join(1..I, n => $"Locate{n}", ", ")},");
				code.AppendLine($@"			{Join(1..I, n => $"Compare{n}", ", ")},");
				code.AppendLine($@"			{Join(1..I, n => $"Subdivide{n}", ", ")}>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		where Locate{j} : struct, IFunc<T, Axis{j}>");
				}
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		where Compare{j} : struct, IFunc<Axis{j}, Axis{j}, CompareResult>");
				}
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		where Subdivide{j} : struct, IFunc<(int Count, int Depth, System.Collections.Generic.IEnumerable<Axis{j}> Values, (Bound<Axis{j}> Min, Bound<Axis{j}> Max) Bounds), Axis{j}>");
				}
				code.AppendLine($@"	{{");

				#region Fields

				code.AppendLine($@"		internal {(i < 30 ? "const" : "readonly static")} {(i < 30 ? "int" : "BigInteger")} ChildrenPerNode = {(i < 30 ? $"{Math.Pow(2, i)}" : $"BigInteger.Pow(2, {i})")};");
				code.AppendLine($@"");
				code.AppendLine($@"		internal Node _top;");
				code.AppendLine($@"		internal int _naturalLogLower = 1;");
				code.AppendLine($@"		internal int _naturalLogUpper = 1;");
				code.AppendLine($@"		internal int _load = 1;");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		internal Locate{j} _locate{j};");
				}
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		internal Compare{j} _compare{j};");
				}
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		internal Subdivide{j} _subdivide{j};");
				}
				code.AppendLine($@"");

				#endregion

				#region Nested Types

				code.AppendLine($@"		#region Nested Types");
				code.AppendLine($@"");

				#region Node

				code.AppendLine($@"		/// <summary>Can be a leaf or a branch.</summary>");
				code.AppendLine($@"		internal abstract class Node");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			internal Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> Bounds;");
				code.AppendLine($@"			internal Branch Parent;");
				code.AppendLine($@"			internal {(i < 30 ? "int" : nameof(BigInteger))} Index;");
				code.AppendLine($@"			internal int Count;");
				code.AppendLine($@"");
				code.AppendLine($@"			/// <summary>The depth this node is located in the Omnitree.</summary>");
				code.AppendLine($@"			internal int Depth");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				get");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					int depth = -1;");
				code.AppendLine($@"					for (Node node = this; node is not null; node = node.Parent)");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						depth++;");
				code.AppendLine($@"					}}");
				code.AppendLine($@"					return depth;");
				code.AppendLine($@"				}}");
				code.AppendLine($@"			}}");
				code.AppendLine($@"");
				code.AppendLine($@"			/// <summary>Constructs a node.</summary>");
				code.AppendLine($@"			/// <param name=""bounds"">The bounds of this node.</param>");
				code.AppendLine($@"			/// <param name=""parent"">The parent of this node.</param>");
				code.AppendLine($@"			/// <param name=""index"">The number of elements stored in this node and its children.</param>");
				code.AppendLine($@"			internal Node(Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> bounds, Branch parent, {(i < 30 ? "int" : nameof(BigInteger))} index)");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				Bounds = bounds;");
				code.AppendLine($@"				Parent = parent;");
				code.AppendLine($@"				Index = index;");
				code.AppendLine($@"			}}");
				code.AppendLine($@"");
				code.AppendLine($@"			internal Node(Node nodeToClone)");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				Bounds = nodeToClone.Bounds;");
				code.AppendLine($@"				Parent = nodeToClone.Parent;");
				code.AppendLine($@"				Index = nodeToClone.Index;");
				code.AppendLine($@"				Count = nodeToClone.Count;");
				code.AppendLine($@"			}}");
				code.AppendLine($@"");
				code.AppendLine($@"			internal abstract Node Clone();");
				code.AppendLine($@"");
				code.AppendLine($@"			internal abstract int MaxDepth {{ get; }}");
				code.AppendLine($@"");
				code.AppendLine($@"			internal abstract int NodeCount {{ get; }}");
				code.AppendLine($@"");
				code.AppendLine($@"			internal abstract int BranchCount {{ get; }}");
				code.AppendLine($@"");
				code.AppendLine($@"			internal abstract int LeafCount {{ get; }}");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");

				#endregion

				#region Branch

				code.AppendLine($@"		/// <summary>A branch in the tree. Only contains nodes.</summary>");
				code.AppendLine($@"		internal class Branch : Node");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			internal Node[] Children;");
				code.AppendLine($@"			internal Omnitree.Vector<{Join(1..I, n => $"Axis{n}", ", ")}> PointOfDivision;");
				code.AppendLine($@"");
				code.AppendLine($@"			/// <summary>Gets child by index.</summary>");
				code.AppendLine($@"			/// <param name=""child_index"">The index of the child to get.</param>");
				code.AppendLine($@"			/// <returns>The child of the given index or null if non-existent.</returns>");
				code.AppendLine($@"			internal Node this[{(i < 30 ? "int" : nameof(BigInteger))} child_index]");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				get");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					if (Children is null)");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						return null;");
				code.AppendLine($@"					}}");
				code.AppendLine($@"					if (Children.Length == ChildrenPerNode)");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						return Children[(int)child_index];");
				code.AppendLine($@"					}}");
				code.AppendLine($@"					foreach (Node node in Children)");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						if (node.Index == child_index)");
				code.AppendLine($@"						{{");
				code.AppendLine($@"							return node;");
				code.AppendLine($@"						}}");
				code.AppendLine($@"					}}");
				code.AppendLine($@"					return null;");
				code.AppendLine($@"				}}");
				code.AppendLine($@"				set");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					// This error check should be unnecessary... but fuck it... might as well");
				code.AppendLine($@"					if (value.Index != child_index)");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						throw new System.Exception(""Bug in Omnitree(index / property mis - match when setting a child on a branch)"");");
				code.AppendLine($@"					}}");
				code.AppendLine($@"");
				code.AppendLine($@"					if (Children is null)");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						Children = Ɐ(value);");
				code.AppendLine($@"						return;");
				code.AppendLine($@"					}}");
				code.AppendLine($@"					else if (Children.Length == ChildrenPerNode)");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						Children[(int)child_index] = value;");
				code.AppendLine($@"						return;");
				code.AppendLine($@"					}}");
				code.AppendLine($@"					for (int i = 0; i < Children.Length; i++)");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						if (Children[i].Index == child_index)");
				code.AppendLine($@"						{{");
				code.AppendLine($@"							Children[i] = value;");
				code.AppendLine($@"							return;");
				code.AppendLine($@"						}}");
				code.AppendLine($@"					}}");
				code.AppendLine($@"					Node[] newArray = new Node[Children.Length + 1];");
				code.AppendLine($@"					if (newArray.Length == ChildrenPerNode)");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						for (int i = 0; i < Children.Length; i++)");
				code.AppendLine($@"						{{");
				code.AppendLine($@"							newArray[(int)Children[i].Index] = Children[i];");
				code.AppendLine($@"						}}");
				code.AppendLine($@"						newArray[(int)value.Index] = value;");
				code.AppendLine($@"					}}");
				code.AppendLine($@"					else");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						Array.Copy(Children, newArray, Children.Length);");
				code.AppendLine($@"						newArray[newArray.Length - 1] = value;");
				code.AppendLine($@"					}}");
				code.AppendLine($@"					Children = newArray;");
				code.AppendLine($@"				}}");
				code.AppendLine($@"			}}");
				code.AppendLine($@"");
				code.AppendLine($@"			internal Branch(Omnitree.Vector<{Join(1..I, n => $"Axis{n}", ", ")}> pointOfDivision, Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> bounds, Branch parent, {(i < 30 ? "int" : nameof(BigInteger))} index)");
				code.AppendLine($@"				: base(bounds, parent, index)");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				PointOfDivision = pointOfDivision;");
				code.AppendLine($@"			}}");
				code.AppendLine($@"");
				code.AppendLine($@"			internal Branch(Branch branchToClone) : base(branchToClone)");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				Children = branchToClone.Children.Clone() as Node[];");
				code.AppendLine($@"				PointOfDivision = branchToClone.PointOfDivision;");
				code.AppendLine($@"			}}");
				code.AppendLine($@"");
				code.AppendLine($@"			internal override Node Clone() => new Branch(this);");
				code.AppendLine($@"");
				code.AppendLine($@"			internal override int MaxDepth");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				get");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					int maxDepth = 0;");
				code.AppendLine($@"					foreach (Node node in Children)");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						if (node is not null)");
				code.AppendLine($@"						{{");
				code.AppendLine($@"							maxDepth = Math.Max(maxDepth, node.MaxDepth + 1);");
				code.AppendLine($@"						}}");
				code.AppendLine($@"					}}");
				code.AppendLine($@"					return maxDepth;");
				code.AppendLine($@"				}}");
				code.AppendLine($@"			}}");
				code.AppendLine($@"");
				code.AppendLine($@"			internal override int NodeCount");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				get");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					int nodeCount = 1;");
				code.AppendLine($@"					foreach (Node node in Children)");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						if (node is not null)");
				code.AppendLine($@"						{{");
				code.AppendLine($@"							nodeCount += node.NodeCount;");
				code.AppendLine($@"						}}");
				code.AppendLine($@"					}}");
				code.AppendLine($@"					return nodeCount;");
				code.AppendLine($@"				}}");
				code.AppendLine($@"			}}");
				code.AppendLine($@"");
				code.AppendLine($@"			internal override int BranchCount");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				get");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					int branchCount = 1;");
				code.AppendLine($@"					foreach (Node node in Children)");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						if (node is not null)");
				code.AppendLine($@"						{{");
				code.AppendLine($@"							branchCount += node.BranchCount;");
				code.AppendLine($@"						}}");
				code.AppendLine($@"					}}");
				code.AppendLine($@"					return branchCount;");
				code.AppendLine($@"				}}");
				code.AppendLine($@"			}}");
				code.AppendLine($@"");
				code.AppendLine($@"			internal override int LeafCount");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				get");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					int leafCount = 0;");
				code.AppendLine($@"					foreach (Node node in Children)");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						if (node is not null)");
				code.AppendLine($@"						{{");
				code.AppendLine($@"							leafCount += node.LeafCount;");
				code.AppendLine($@"						}}");
				code.AppendLine($@"					}}");
				code.AppendLine($@"					return leafCount;");
				code.AppendLine($@"				}}");
				code.AppendLine($@"			}}");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");

				#endregion

				#region Leaf

				code.AppendLine($@"		/// <summary>A branch in the tree. Only contains items.</summary>");
				code.AppendLine($@"		internal class Leaf : Node");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			internal class Node");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				internal T Value;");
				code.AppendLine($@"				internal Leaf.Node Next;");
				code.AppendLine($@"");
				code.AppendLine($@"				internal Node(T value, Leaf.Node next)");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					Value = value;");
				code.AppendLine($@"					Next = next;");
				code.AppendLine($@"				}}");
				code.AppendLine($@"			}}");
				code.AppendLine($@"");
				code.AppendLine($@"			internal Leaf.Node Head;");
				code.AppendLine($@"");
				code.AppendLine($@"			internal Leaf(Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> bounds, Branch parent, {(i < 30 ? "int" : nameof(BigInteger))} index)");
				code.AppendLine($@"				: base(bounds, parent, index) {{ }}");
				code.AppendLine($@"");
				code.AppendLine($@"			internal Leaf(Leaf leaf) : base(leaf)");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				Head = new Node(leaf.Head.Value, null);");
				code.AppendLine($@"				Node a = Head;");
				code.AppendLine($@"				Node b = leaf.Head;");
				code.AppendLine($@"				while (b is not null)");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					a.Next = new Node(b.Next.Value, null);");
				code.AppendLine($@"					a = a.Next;");
				code.AppendLine($@"					b = b.Next;");
				code.AppendLine($@"				}}");
				code.AppendLine($@"			}}");
				code.AppendLine($@"");
				code.AppendLine($@"			internal void Add(T addition)");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				Head = new Leaf.Node(addition, Head);");
				code.AppendLine($@"				Count++;");
				code.AppendLine($@"			}}");
				code.AppendLine($@"");
				code.AppendLine($@"			internal override OmnitreePointsLinked<T, {Join(1..I, n => $"Axis{n}", ", ")}, {Join(1..I, n => $"Locate{n}", ", ")}, {Join(1..I, n => $"Compare{n}", ", ")}, {Join(1..I, n => $"Subdivide{n}", ", ")}>.Node Clone() => new Leaf(this);");
				code.AppendLine($@"");
				code.AppendLine($@"			internal override int MaxDepth => 0;");
				code.AppendLine($@"");
				code.AppendLine($@"			internal override int NodeCount => 1;");
				code.AppendLine($@"");
				code.AppendLine($@"			internal override int BranchCount => 0;");
				code.AppendLine($@"");
				code.AppendLine($@"			internal override int LeafCount => 1;");
				code.AppendLine($@"");
				code.AppendLine($@"			internal System.Collections.Generic.IEnumerable<Axis> GetEnumerable<Axis, Locate>(Locate locate = default)");
				code.AppendLine($@"				where Locate : struct, IFunc<T, Axis>");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				for (Node node = Head; node is not null; node = node.Next)");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					yield return locate.Invoke(node.Value);");
				code.AppendLine($@"				}}");
				code.AppendLine($@"			}}");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");

				#endregion

				code.AppendLine($@"		#endregion");
				code.AppendLine($@"");

				#endregion

				#region Constructors

				code.AppendLine($@"		#region Constructors");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>This constructor is for cloning purposes.</summary>");
				code.AppendLine($@"		internal OmnitreePointsLinked(");
				code.AppendLine($@"			OmnitreePointsLinked<T,");
				code.AppendLine($@"				{Join(1..I, n => $"Axis{n}", ", ")},");
				code.AppendLine($@"				{Join(1..I, n => $"Locate{n}", ", ")},");
				code.AppendLine($@"				{Join(1..I, n => $"Compare{n}", ", ")},");
				code.AppendLine($@"				{Join(1..I, n => $"Subdivide{n}", ", ")}>");
				code.AppendLine($@"			omnitree)");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			_top = omnitree._top.Clone();");
				code.AppendLine($@"			_load = omnitree._load;");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			_locate{j} = omnitree._locate{j};");
					code.AppendLine($@"			_compare{j} = omnitree._compare{j};");
					code.AppendLine($@"			_subdivide{j} = omnitree._subdivide{j};");
				}
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"	/// <summary>Constructs a new omnitree.</summary>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"	/// <param name=""locate{j}"">The function this tree is using to locate <typeparamref name=""T""/>'s along the {j}D axis.</param>");
					code.AppendLine($@"	/// <param name=""compare{j}"">The function this tree is using to compare <typeparamref name=""T""/>'s along the {j}D axis.</param>");
					code.AppendLine($@"	/// <param name=""subdivide{j}"">The function this tree is using to subdivide <typeparamref name=""T""/>'s along the {j}D axis.</param>");
				}
				code.AppendLine($@"		public OmnitreePointsLinked(");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			Locate{j} locate{j} = default,");
				}
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			Compare{j} compare{j} = default,");
				}
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			Subdivide{j} subdivide{j} = default{(j == i ? ")" : ",")}");
				}
				code.AppendLine($@"		{{");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			_locate{j} = locate{j};");
					code.AppendLine($@"			_compare{j} = compare{j};");
					code.AppendLine($@"			_subdivide{j} = subdivide{j};");
				}
				code.AppendLine($@"			_top = new Leaf(Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}>.None, null, -1);");
				code.AppendLine($@"			Towel.DataStructures.Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		#endregion");
				code.AppendLine($@"");

				#endregion

				#region Properties

				code.AppendLine($@"		#region Properties");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <inheritdoc/>");
				code.AppendLine($@"		public int Dimensions => {i};");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <inheritdoc/>");
				code.AppendLine($@"		public int Count => _top.Count;");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>The current maximum depth of this tree. Warning! Not an O(1) operation.</summary>");
				code.AppendLine($@"		public int MaxDepth => _top.MaxDepth;");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>The current number of nodes in this tree. Warning! Not an O(1) operation.</summary>");
				code.AppendLine($@"		public int NodeCount => _top.NodeCount;");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>The current number of branches in this tree. Warning! Not an O(1) operation.</summary>");
				code.AppendLine($@"		public int BranchCount => _top.BranchCount;");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>The current number of leaves in this tree. Warning! Not an O(1) operation.</summary>");
				code.AppendLine($@"		public int LeafCount => _top.LeafCount;");
				code.AppendLine($@"");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		/// <summary>The function this tree is using to locate <typeparamref name=""T""/>'s along the {i}D axis.</summary>");
					code.AppendLine($@"		public Locate{j} LocateFunction{j} => _locate{j};");
				}
				code.AppendLine($@"");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		/// <summary>The function this tree is using to compare <typeparamref name=""T""/>'s along the {j}D axis.</summary>");
					code.AppendLine($@"		public Compare{j} CompareFunction{j} => _compare{j};");
				}
				code.AppendLine($@"");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		/// <summary>The function this tree is using to subdivide <typeparamref name=""T""/>'s along the {j}D axis.</summary>");
					code.AppendLine($@"		public Subdivide{j} SubdivideFunction{j} => _subdivide{j};");
				}
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Steps through all the items at a given coordinate.</summary>");
				code.AppendLine($@"		public System.Collections.Generic.IEnumerable<T> this[{Join(1..I, n => $"Axis{n} axis{n}", ", ")}] => throw new NotImplementedException();");
				code.AppendLine($@"");
				code.AppendLine($@"		#endregion");
				code.AppendLine($@"");

				#endregion

				#region Methods

				code.AppendLine($@"		#region Methods");
				code.AppendLine($@"");

				#region Add

				code.AppendLine($@"		#region TryAdd");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <inheritdoc />");
				code.AppendLine($@"		public (bool Success, Exception? Exception) TryAdd(T value)");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			if (_top.Count is int.MaxValue)");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				return (false, new(""Omnitree.Count is int.MaxValue""));");
				code.AppendLine($@"			}}");
				code.AppendLine($@"			Towel.DataStructures.Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);");
				code.AppendLine($@"			Omnitree.Vector<{Join(1..I, n => $"Axis{n}", ", ")}> location = FullLocate(value);");
				code.AppendLine($@"			if (_top is Leaf top && top.Count >= _load)");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				_top = new Branch(DeterminePointOfDivision(top, 0), Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}>.None, null, -1);");
				code.AppendLine($@"				for (Leaf.Node list = top.Head; list is not null; list = list.Next)");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					Add(list.Value, _top, FullLocate(list.Value), 0);");
				code.AppendLine($@"				}}");
				code.AppendLine($@"			}}");
				code.AppendLine($@"			Add(value, _top, location, 0);");
				code.AppendLine($@"			return (true, null);");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		internal void Add(T value, Node node, Omnitree.Vector<{Join(1..I, n => $"Axis{n}", ", ")}> location, int depth)");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			if (node is Leaf leaf)");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				if (depth >= _load || leaf.Count < _load)");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					leaf.Add(value);");
				code.AppendLine($@"					return;");
				code.AppendLine($@"				}}");
				code.AppendLine($@"				else");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					Branch parent = node.Parent;");
				code.AppendLine($@"					int child_index = DetermineChildIndex(parent.PointOfDivision, location);");
				code.AppendLine($@"					Branch growth = new(DeterminePointOfDivision(leaf, depth), leaf.Bounds, parent, child_index);");
				code.AppendLine($@"					parent[child_index] = growth;");
				code.AppendLine($@"					for (Leaf.Node list = leaf.Head; list is not null; list = list.Next)");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						Omnitree.Vector<{Join(1..I, n => $"Axis{n}", ", ")}> temp_location = FullLocate(list.Value);");
				code.AppendLine($@"						if (Omnitree.ContainsCheck(growth.Bounds, temp_location, {Join(1..I, n => $"_compare{n}", ", ")}))");
				code.AppendLine($@"						{{");
				code.AppendLine($@"							Add(list.Value, growth, temp_location, depth);");
				code.AppendLine($@"						}}");
				code.AppendLine($@"						else");
				code.AppendLine($@"						{{");
				code.AppendLine($@"							AdjustParentCounts(parent, 1);");
				code.AppendLine($@"							Add(list.Value, _top, temp_location, 0);");
				code.AppendLine($@"						}}");
				code.AppendLine($@"					}}");
				code.AppendLine($@"					Add(value, growth, location, depth);");
				code.AppendLine($@"					return;");
				code.AppendLine($@"				}}");
				code.AppendLine($@"			}}");
				code.AppendLine($@"			else");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				Branch branch = node as Branch;");
				code.AppendLine($@"				int child_index = this.DetermineChildIndex(branch.PointOfDivision, location);");
				code.AppendLine($@"				Node child_node = branch[child_index];");
				code.AppendLine($@"				if (child_node is null)");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					Leaf new_leaf = new(DetermineChildBounds(branch, child_index), branch, child_index);");
				code.AppendLine($@"					branch[child_index] = new_leaf;");
				code.AppendLine($@"					new_leaf.Add(value);");
				code.AppendLine($@"				}}");
				code.AppendLine($@"				else");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					Add(value, child_node, location, depth + 1);");
				code.AppendLine($@"				}}");
				code.AppendLine($@"				branch.Count++;");
				code.AppendLine($@"			}}");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		#endregion");
				code.AppendLine($@"");

				#endregion

				#region DeterminePointOfDivision

				code.AppendLine($@"		#region DeterminePointOfDivision");
				code.AppendLine($@"");
				code.AppendLine($@"		internal Omnitree.Vector<{Join(1..I, n => $"Axis{n}", ", ")}> DeterminePointOfDivision(Leaf leaf, int depth) =>");
				code.AppendLine($@"			new(");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"				_subdivide{j}.Invoke((leaf.Count, depth, leaf.GetEnumerable<Axis{j}, Locate{j}>(_locate{j}), (leaf.Bounds.Min{j}, leaf.Bounds.Max{j}))){(j == i ? ");" : ",")}");
				}
				code.AppendLine($@"");
				code.AppendLine($@"		#endregion");
				code.AppendLine($@"");

				#endregion

				#region DetermineChildBounds

				code.AppendLine($@"		#region DetermineChildBounds");
				code.AppendLine($@"");
				code.AppendLine($@"		internal Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> DetermineChildBounds(Branch branch, int child_index)");
				code.AppendLine($@"		{{");
				for (int j = i; j > 0; j--)
				{
					code.AppendLine($@"			Towel.DataStructures.Omnitree.Bound<Axis{j}> min{j}, max{j};");
					code.AppendLine($@"			if (child_index >= {(2 << (j - 1)) / 2})");
					code.AppendLine($@"			{{");
					code.AppendLine($@"				min{j} = branch.PointOfDivision.Axis{j};");
					code.AppendLine($@"				max{j} = branch.Bounds.Max{j};");
					code.AppendLine($@"				child_index -= {(2 << (j - 1)) / 2};");
					code.AppendLine($@"			}}");
					code.AppendLine($@"			else");
					code.AppendLine($@"			{{");
					code.AppendLine($@"				min{j} = branch.Bounds.Min{j};");
					code.AppendLine($@"				max{j} = branch.PointOfDivision.Axis{j};");
					code.AppendLine($@"			}}");
				}
				code.AppendLine($@"			return new(");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"				min{j}, max{j}{(j == i ? ");" : ",")}");
				}
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		#endregion");
				code.AppendLine($@"");

				#endregion

				#region Remove (predicate)

				code.AppendLine($@"		#region Remove (predicate)");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Removes all the values qualified by the predicate.</summary>");
				code.AppendLine($@"		/// <typeparam name=""TPredicate"">The predicate to qualify removals.</typeparam>");
				code.AppendLine($@"		/// <param name=""predicate"">The predicate to qualify removals.</param>");
				code.AppendLine($@"		public int Remove<TPredicate>(TPredicate predicate = default) where TPredicate : struct, IFunc<T, bool>");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			int count = Remove(_top, predicate);");
				code.AppendLine($@"			Towel.DataStructures.Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);");
				code.AppendLine($@"			return count;");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		internal int Remove<TPredicate>(Node node, TPredicate predicate) where TPredicate : struct, IFunc<T, bool>");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			int removals = 0;");
				code.AppendLine($@"			if (node is Leaf leaf)");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				while (leaf.Head is not null && predicate.Invoke(leaf.Head.Value))");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					leaf.Head = leaf.Head.Next;");
				code.AppendLine($@"					removals++;");
				code.AppendLine($@"				}}");
				code.AppendLine($@"				if (leaf.Head is not null)");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					Leaf.Node list = leaf.Head;");
				code.AppendLine($@"					while (list.Next is not null)");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						if (predicate.Invoke(list.Next.Value))");
				code.AppendLine($@"						{{");
				code.AppendLine($@"							list.Next = list.Next.Next;");
				code.AppendLine($@"							removals++;");
				code.AppendLine($@"						}}");
				code.AppendLine($@"					}}");
				code.AppendLine($@"				}}");
				code.AppendLine($@"				leaf.Count -= removals;");
				code.AppendLine($@"			}}");
				code.AppendLine($@"			else if (node is Branch branch)");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				int skipped = 0;");
				code.AppendLine($@"				for (int i = 0; i + skipped < branch.Children.Length;)");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					removals += Remove(branch.Children[i], predicate);");
				code.AppendLine($@"					if (branch.Children[i].Count == 0)");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];");
				code.AppendLine($@"					}}");
				code.AppendLine($@"					else");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						i++;");
				code.AppendLine($@"					}}");
				code.AppendLine($@"				}}");
				code.AppendLine($@"				Node[] newArray = new Node[branch.Children.Length - skipped];");
				code.AppendLine($@"				Array.Copy(branch.Children, newArray, newArray.Length);");
				code.AppendLine($@"				branch.Children = newArray;");
				code.AppendLine($@"				branch.Count -= removals;");
				code.AppendLine($@"				if (branch.Count < _load && branch.Count != 0)");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					ShrinkChild(branch.Parent, branch.Index);");
				code.AppendLine($@"				}}");
				code.AppendLine($@"			}}");
				code.AppendLine($@"			return removals;");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		#endregion");
				code.AppendLine($@"");

				#endregion

				#region Remove (vector)

				code.AppendLine($@"		#region Remove (vector)");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Removes all the values at a given vector.</summary>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		/// <param name=""axis{j}"">The coordinate along the {j} axis.</param>");
				}
				code.AppendLine($@"		/// <returns>The number of values that were removed.</returns>");
				code.AppendLine($@"		public int Remove({Join(1..I, n => $"Axis{n} axis{n}", ", ")}) =>");
				code.AppendLine($@"			Remove({Join(1..I, n => $"axis{n}, axis{n}", ", ")});");
				code.AppendLine($@"");
				code.AppendLine($@"		#endregion");
				code.AppendLine($@"");

				#endregion

				#region Remove (space)

				code.AppendLine($@"		#region Remove (space)");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Removes all the items in a given space.</summary>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		/// <param name=""min{j}"">The minimum coordinate of the space along the {j} axis.</param>");
					code.AppendLine($@"		/// <param name=""max{j}"">The maximum coordinate of the space along the {j} axis.</param>");
				}
				code.AppendLine($@"		public int Remove(");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			Axis{j} min{j}, Axis{j} max{j}{(j == i ? ")" : ",")}");
				}
				code.AppendLine($@"		{{");
				code.AppendLine($@"			int count = Remove(_top, new(");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"				min{j}, max{j}{(j == i ? "));" : ",")}");
				}
				code.AppendLine($@"			Towel.DataStructures.Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);");
				code.AppendLine($@"			return count;");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Removes all the items in a given space.</summary>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		/// <param name=""min{j}"">The minimum coordinate of the space along the {j} axis.</param>");
					code.AppendLine($@"		/// <param name=""max{j}"">The maximum coordinate of the space along the {j} axis.</param>");
				}
				code.AppendLine($@"		public int Remove(");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			Towel.DataStructures.Omnitree.Bound<Axis{j}> min{j}, Towel.DataStructures.Omnitree.Bound<Axis{j}> max{j}{(j == i ? ")" : ",")}");
				}
				code.AppendLine($@"		{{");
				code.AppendLine($@"			int count = Remove(_top, new(");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"				min{j}, max{j}{(j == i ? "));" : ",")}");
				}
				code.AppendLine($@"			Towel.DataStructures.Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);");
				code.AppendLine($@"			return count;");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		internal int Remove(Node node, Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> bounds)");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			int removals = 0;");
				code.AppendLine($@"			if (Omnitree.OverlapCheck(bounds, node.Bounds, {Join(1..I, n => $"_compare{n}", ", ")}))");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				if (node is Leaf leaf)");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					Leaf.Node current_node = leaf.Head;");
				code.AppendLine($@"					Leaf.Node previous_node = null;");
				code.AppendLine($@"					while (!(current_node is null))");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						Leaf.Node temp_previous = current_node;");
				code.AppendLine($@"						if (Omnitree.ContainsCheck(bounds, FullLocate(current_node.Value), {Join(1..I, n => $"_compare{n}", ", ")}))");
				code.AppendLine($@"						{{");
				code.AppendLine($@"							removals++;");
				code.AppendLine($@"							if (current_node == leaf.Head)");
				code.AppendLine($@"							{{");
				code.AppendLine($@"								leaf.Head = leaf.Head.Next;");
				code.AppendLine($@"							}}");
				code.AppendLine($@"							else");
				code.AppendLine($@"							{{");
				code.AppendLine($@"								previous_node.Next = current_node.Next;");
				code.AppendLine($@"								temp_previous = previous_node;");
				code.AppendLine($@"							}}");
				code.AppendLine($@"						}}");
				code.AppendLine($@"						previous_node = temp_previous;");
				code.AppendLine($@"						current_node = current_node.Next;");
				code.AppendLine($@"					}}");
				code.AppendLine($@"					leaf.Count -= removals;");
				code.AppendLine($@"				}}");
				code.AppendLine($@"				else if (node is Branch branch)");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					int skipped = 0;");
				code.AppendLine($@"					for (int i = 0; i + skipped < branch.Children.Length;)");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						removals += Remove(branch.Children[i], bounds);");
				code.AppendLine($@"						if (branch.Children[i].Count == 0)");
				code.AppendLine($@"						{{");
				code.AppendLine($@"							branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];");
				code.AppendLine($@"						}}");
				code.AppendLine($@"						else");
				code.AppendLine($@"						{{");
				code.AppendLine($@"							i++;");
				code.AppendLine($@"						}}");
				code.AppendLine($@"					}}");
				code.AppendLine($@"					Node[] newArray = new Node[branch.Children.Length - skipped];");
				code.AppendLine($@"					Array.Copy(branch.Children, newArray, newArray.Length);");
				code.AppendLine($@"					branch.Children = newArray;");
				code.AppendLine($@"					branch.Count -= removals;");
				code.AppendLine($@"					if (branch.Count < _load && branch.Count > 0)");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						ShrinkChild(branch.Parent, branch.Index);");
				code.AppendLine($@"					}}");
				code.AppendLine($@"				}}");
				code.AppendLine($@"			}}");
				code.AppendLine($@"			return removals;");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		#endregion");
				code.AppendLine($@"");

				#endregion

				#region Remove (value)

				code.AppendLine($@"		#region Remove (value)");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Removes all the items in a given space.</summary>");

				code.AppendLine($@"		public int Remove<TEquate>(T value, TEquate equate = default)");
				code.AppendLine($@"			where TEquate : struct, IFunc<T, T, bool>");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			var x = FullLocate(value);");
				code.AppendLine($@"			int count = Remove<PredicateFromEquateAndValue<T, TEquate>>(");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"				x.Axis{j}, x.Axis{j},");
				}
				code.AppendLine($@"				new(value, equate));");
				code.AppendLine($@"			Towel.DataStructures.Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);");
				code.AppendLine($@"			return count;");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		#endregion");
				code.AppendLine($@"");

				#endregion

				#region Remove (vector + predicate)

				code.AppendLine($@"		#region Remove (vector + predicate)");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Removes all the items in a given space.</summary>");
				code.AppendLine($@"		/// <typeparam name=""TPredicate"">The predicate to qualify removals.</typeparam>");
				code.AppendLine($@"		/// <param name=""predicate"">The predicate to qualify removals.</param>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		/// <param name=""axis{j}"">The coordinate of the space along the {j} axis.</param>");
				}
				code.AppendLine($@"		public int Remove<TPredicate>({Join(1..I, n => $"Axis{n} axis{n}", ", ")}, TPredicate predicate = default)");
				code.AppendLine($@"			where TPredicate : struct, IFunc<T, bool> =>");
				code.AppendLine($@"			Remove<TPredicate>({Join(1..I, n => $"axis{n}, axis{n}", ", ")}, predicate);");
				code.AppendLine($@"");
				code.AppendLine($@"		#endregion");
				code.AppendLine($@"");

				#endregion

				#region Remove (space + predicate)

				code.AppendLine($@"		#region Remove (space + predicate)");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Removes all the items in a given space.</summary>");
				code.AppendLine($@"		/// <typeparam name=""TPredicate"">The predicate to qualify removals.</typeparam>");
				code.AppendLine($@"		/// <param name=""predicate"">The predicate to qualify removals.</param>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		/// <param name=""min{j}"">The minimum coordinate of the space along the {j} axis.</param>");
					code.AppendLine($@"		/// <param name=""max{j}"">The maximum coordinate of the space along the {j} axis.</param>");
				}
				code.AppendLine($@"		public int Remove<TPredicate>(");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			Axis{j} min{j}, Axis{j} max{j},");
				}
				code.AppendLine($@"			TPredicate predicate = default)");
				code.AppendLine($@"			where TPredicate : struct, IFunc<T, bool>");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			int count = Remove(_top, new(");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"				min{j}, max{j}{(j == i ? ")," : ",")}");
				}
				code.AppendLine($@"				predicate);");
				code.AppendLine($@"			Towel.DataStructures.Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);");
				code.AppendLine($@"			return count;");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Removes all the items in a given space.</summary>");
				code.AppendLine($@"		/// <typeparam name=""TPredicate"">The predicate to qualify removals.</typeparam>");
				code.AppendLine($@"		/// <param name=""predicate"">The predicate to qualify removals.</param>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		/// <param name=""min{j}"">The minimum coordinate of the space along the {j} axis.</param>");
					code.AppendLine($@"		/// <param name=""max{j}"">The maximum coordinate of the space along the {j} axis.</param>");
				}
				code.AppendLine($@"		public int Remove<TPredicate>(");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			Towel.DataStructures.Omnitree.Bound<Axis{j}> min{j}, Towel.DataStructures.Omnitree.Bound<Axis{j}> max{j},");
				}
				code.AppendLine($@"				TPredicate predicate = default)");
				code.AppendLine($@"			where TPredicate : struct, IFunc<T, bool>");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			int count = Remove(_top, new(");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"				min{j}, max{j}{(j == i ? ")," : ",")}");
				}
				code.AppendLine($@"				predicate);");
				code.AppendLine($@"			Towel.DataStructures.Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);");
				code.AppendLine($@"			return count;");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		internal int Remove<TPredicate>(Node node, Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> bounds, TPredicate predicate = default)");
				code.AppendLine($@"			where TPredicate : struct, IFunc<T, bool>");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			int removals = 0;");
				code.AppendLine($@"			if (Omnitree.OverlapCheck(bounds, node.Bounds, {Join(1..I, n => $"_compare{n}", ", ")}))");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				if (node is Leaf leaf)");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					Leaf.Node current_node = leaf.Head;");
				code.AppendLine($@"					Leaf.Node previous_node = null;");
				code.AppendLine($@"					while (!(current_node is null))");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						Leaf.Node temp_previous = current_node;");
				code.AppendLine($@"						if (Omnitree.ContainsCheck(bounds, FullLocate(current_node.Value), {Join(1..I, n => $"_compare{n}", ", ")})  && predicate.Invoke(current_node.Value))");
				code.AppendLine($@"						{{");
				code.AppendLine($@"							removals++;");
				code.AppendLine($@"							if (current_node == leaf.Head)");
				code.AppendLine($@"							{{");
				code.AppendLine($@"								leaf.Head = leaf.Head.Next;");
				code.AppendLine($@"							}}");
				code.AppendLine($@"							else");
				code.AppendLine($@"							{{");
				code.AppendLine($@"								previous_node.Next = current_node.Next;");
				code.AppendLine($@"								temp_previous = previous_node;");
				code.AppendLine($@"							}}");
				code.AppendLine($@"						}}");
				code.AppendLine($@"						previous_node = temp_previous;");
				code.AppendLine($@"						current_node = current_node.Next;");
				code.AppendLine($@"					}}");
				code.AppendLine($@"					leaf.Count -= removals;");
				code.AppendLine($@"				}}");
				code.AppendLine($@"				else if (node is Branch branch)");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					int skipped = 0;");
				code.AppendLine($@"					for (int i = 0; i + skipped < branch.Children.Length;)");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						removals += Remove(branch.Children[i], bounds, predicate);");
				code.AppendLine($@"						if (branch.Children[i].Count == 0)");
				code.AppendLine($@"						{{");
				code.AppendLine($@"							branch.Children[i] = branch.Children[branch.Children.Length - skipped++ - 1];");
				code.AppendLine($@"						}}");
				code.AppendLine($@"						else");
				code.AppendLine($@"						{{");
				code.AppendLine($@"							i++;");
				code.AppendLine($@"						}}");
				code.AppendLine($@"					}}");
				code.AppendLine($@"					Node[] newArray = new Node[branch.Children.Length - skipped];");
				code.AppendLine($@"					Array.Copy(branch.Children, newArray, newArray.Length);");
				code.AppendLine($@"					branch.Children = newArray;");
				code.AppendLine($@"					branch.Count -= removals;");
				code.AppendLine($@"					if (branch.Count < _load && branch.Count > 0)");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						ShrinkChild(branch.Parent, branch.Index);");
				code.AppendLine($@"					}}");
				code.AppendLine($@"				}}");
				code.AppendLine($@"			}}");
				code.AppendLine($@"			return removals;");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		#endregion");
				code.AppendLine($@"");

				#endregion

				#region Clear

				code.AppendLine($@"		#region Clear");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Returns this tree to an empty state.</summary>");
				code.AppendLine($@"		public void Clear()");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			_top = new Leaf(Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}>.None, null, -1);");
				code.AppendLine($@"			Towel.DataStructures.Omnitree.ComputeLoads(_top.Count, ref _naturalLogLower, ref _naturalLogUpper, ref _load);");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		#endregion");
				code.AppendLine($@"");

				#endregion

				#region Clone

				code.AppendLine($@"		#region Clone");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Returns this tree to an empty state.</summary>");
				code.AppendLine($@"		public OmnitreePointsLinked<T,");
				code.AppendLine($@"			{Join(1..I, n => $"Axis{n}", ", ")},");
				code.AppendLine($@"			{Join(1..I, n => $"Locate{n}", ", ")},");
				code.AppendLine($@"			{Join(1..I, n => $"Compare{n}", ", ")},");
				code.AppendLine($@"			{Join(1..I, n => $"Subdivide{n}", ", ")}>");
				code.AppendLine($@"			Clone() => new(this);");
				code.AppendLine($@"");
				code.AppendLine($@"		#endregion");
				code.AppendLine($@"");

				#endregion

				#region CountSubSpace

				code.AppendLine($@"		#region CountSubSpace");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <inheritdoc />");
				code.AppendLine($@"		public int CountSubSpace(");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			Towel.DataStructures.Omnitree.Bound<Axis{j}> min{j}, Towel.DataStructures.Omnitree.Bound<Axis{j}> max{j}{(j == i ? ") =>" : ",")}");
				}
				code.AppendLine($@"			CountSubSpace(_top, new(");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"				min{j}, max{j}{(j == i ? "));" : ",")}");
				}
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Counts the number of values in a sub space of this tree.</summary>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		/// <param name=""axis{j}"">The coordinate along the {j}D axis.</param>");
				}
				code.AppendLine($@"		/// <returns>The number of values in the sub space of this tree.</returns>");
				code.AppendLine($@"		public int CountSubSpace(");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			Axis{j} axis{j}{(j == i ? ") =>" : ",")}");
				}
				code.AppendLine($@"			CountSubSpace(_top, new({Join(1..I, n => $"axis{n}, axis{n}", ", ")}));");
				code.AppendLine($@"");
				code.AppendLine($@"		internal int CountSubSpace(Node node, Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> bounds)");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			int count = 0;");
				code.AppendLine($@"			if (Omnitree.ContainsCheck(bounds, node.Bounds, {Join(1..I, n => $"_compare{n}", ", ")}))");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				count += node.Count;");
				code.AppendLine($@"			}}");
				code.AppendLine($@"			else if (node is Leaf leaf)");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				for (Leaf.Node list = leaf.Head; list is not null; list = list.Next)");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					if (Omnitree.ContainsCheck(bounds, FullLocate(list.Value), {Join(1..I, n => $"_compare{n}", ", ")}))");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						count++;");
				code.AppendLine($@"					}}");
				code.AppendLine($@"				}}");
				code.AppendLine($@"			}}");
				code.AppendLine($@"			else if (node is Branch branch)");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				if (!Omnitree.StraddlesLines(branch.Bounds, branch.PointOfDivision, {Join(1..I, n => $"_compare{n}", ", ")}))");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					int child_index = DetermineChildIndex(branch.PointOfDivision, bounds);");
				code.AppendLine($@"					Node child = branch[child_index];");
				code.AppendLine($@"					if (child is not null)");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						count += CountSubSpace(child, bounds);");
				code.AppendLine($@"					}}");
				code.AppendLine($@"				}}");
				code.AppendLine($@"				else");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					foreach (Node child in branch.Children)");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						count += CountSubSpace(child, bounds);");
				code.AppendLine($@"					}}");
				code.AppendLine($@"				}}");
				code.AppendLine($@"			}}");
				code.AppendLine($@"			return count;");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		#endregion");
				code.AppendLine($@"");

				#endregion

				#region DetermineChildIndex

				code.AppendLine($@"		#region DetermineChildIndex");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Computes the child index that contains the desired dimensions.</summary>");
				code.AppendLine($@"		/// <param name=""pointOfDivision"">The point of division to compare against.</param>");
				code.AppendLine($@"		/// <param name=""bounds"">The dimensions to determine the child index.</param>");
				code.AppendLine($@"		/// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>");
				code.AppendLine($@"		internal int DetermineChildIndex(Omnitree.Vector<{Join(1..I, n => $"Axis{n}", ", ")}> pointOfDivision, Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> bounds)");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			if (Omnitree.StraddlesLines(bounds, pointOfDivision, {Join(1..I, n => $"_compare{n}", ", ")}))");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				return -1;");
				code.AppendLine($@"			}}");
				code.AppendLine($@"			int child = 0;");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			if (!bounds.Min{j}.Exists || _compare{j}.Invoke(bounds.Min{j}.Value, pointOfDivision.Axis{j}) is not Less) child += 1 << {j - 1};");
				}
				code.AppendLine($@"			return child;");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Computes the child index that contains the desired dimensions.</summary>");
				code.AppendLine($@"		/// <param name=""pointOfDivision"">The point of division to compare against.</param>");
				code.AppendLine($@"		/// <param name=""vector"">The dimensions to determine the child index.</param>");
				code.AppendLine($@"		/// <returns>The computed child index based on the coordinates relative to the center of the node.</returns>");
				code.AppendLine($@"		internal int DetermineChildIndex(Omnitree.Vector<{Join(1..I, n => $"Axis{n}", ", ")}> pointOfDivision, Omnitree.Vector<{Join(1..I, n => $"Axis{n}", ", ")}> vector)");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			int child = 0;");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			if (_compare{j}.Invoke(vector.Axis{j}, pointOfDivision.Axis{j}) is not Less) child += 1 << {j - 1};");
				}
				code.AppendLine($@"			return child;");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		#endregion");
				code.AppendLine($@"");

				#endregion

				#region ShrinkChild

				code.AppendLine($@"		#region ShrinkChild");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Converts a branch back into a leaf when the count is reduced.</summary>");
				code.AppendLine($@"		/// <param name=""parent"">The parent to shrink a child of.</param>");
				code.AppendLine($@"		/// <param name=""child_index"">The index of the child to shrink.</param>");
				code.AppendLine($@"		internal void ShrinkChild(Branch parent, int child_index)");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			Leaf leaf;");
				code.AppendLine($@"			Node removal = null;");
				code.AppendLine($@"			if (parent is null)");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				removal = _top;");
				code.AppendLine($@"				leaf = new Leaf(Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}>.None, null, -1);");
				code.AppendLine($@"				_top = leaf;");
				code.AppendLine($@"			}}");
				code.AppendLine($@"			else");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				removal = parent[child_index];");
				code.AppendLine($@"				leaf = new Leaf(removal.Bounds, removal.Parent, removal.Index);");
				code.AppendLine($@"				parent[child_index] = leaf;");
				code.AppendLine($@"			}}");
				#warning TODO: optimize
				code.AppendLine($@"			// TODO: optimize");
				code.AppendLine($@"			Stepper<SAction<T>>(removal, new Action<T>(step => {{ leaf.Add(step); }}));");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		#endregion");
				code.AppendLine($@"");

				#endregion

				#region AdjustParentCounts

				code.AppendLine($@"		#region AdjustParentCounts");
				code.AppendLine($@"");
				code.AppendLine($@"		internal void AdjustParentCounts(Node parent, int adjustment)");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			for (Node node = parent; node is not null; node = node.Parent)");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				node.Count += adjustment;");
				code.AppendLine($@"			}}");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		#endregion");
				code.AppendLine($@"");

				#endregion

				#region GetContainingParent

				code.AppendLine($@"		#region NearestContainingNode");
				code.AppendLine($@"");
				code.AppendLine($@"		internal Node NearestContainingNode(Node node, Omnitree.Vector<{Join(1..I, n => $"Axis{n}", ", ")}> vector)");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			while (node is not null && !Omnitree.ContainsCheck(node.Bounds, vector, {Join(1..I, n => $"_compare{n}", ", ")}))");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				node = node.Parent;");
				code.AppendLine($@"			}}");
				code.AppendLine($@"			return node;");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		#endregion");
				code.AppendLine($@"");

				#endregion

				#region FullLocate

				code.AppendLine($@"		#region FullLocate");
				code.AppendLine($@"");
				code.AppendLine($@"		internal Omnitree.Vector<{Join(1..I, n => $"Axis{n}", ", ")}> FullLocate(T value) => new(");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			_locate{j}.Invoke(value){(j == i ? ");" : ",")}");
				}
				code.AppendLine($@"");
				code.AppendLine($@"		#endregion");
				code.AppendLine($@"");

				#endregion

				#region Update

				code.AppendLine($@"		#region Update");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <inheritdoc/>");
				code.AppendLine($@"		public void Update()");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			throw new NotImplementedException();");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		#endregion");
				code.AppendLine($@"");

				#endregion

				#region Update (space)

				code.AppendLine($@"		#region Update (space)");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <inheritdoc/>");
				code.AppendLine($@"		public void Update(");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			Bound<Axis{j}> min{j}, Bound<Axis{j}> max{j}{(j == i ? ")" : ",")}");
				}
				code.AppendLine($@"		{{");
				code.AppendLine($@"			throw new NotImplementedException();");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		#endregion");
				code.AppendLine($@"");

				#endregion

				#region Stepper

				code.AppendLine($@"		#region Stepper");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Traverses this tree and performs a step on every value.</summary>");
				code.AppendLine($@"		/// <typeparam name=""Step"">The action to perform on every during traversal.</typeparam>");
				code.AppendLine($@"		/// <param name=""step"">The action to perform on every during traversal.</param>");
				code.AppendLine($@"		public void Stepper<Step>(Step step = default)");
				code.AppendLine($@"			where Step : struct, IAction<T> =>");
				code.AppendLine($@"			Stepper(_top, step);");
				code.AppendLine($@"");
				code.AppendLine($@"		internal void Stepper<Step>(Node node, Step step)");
				code.AppendLine($@"			where Step : struct, IAction<T>");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			if (node is Leaf leaf)");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				Leaf.Node list = leaf.Head;");
				code.AppendLine($@"				while (list is not null)");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					step.Invoke(list.Value);");
				code.AppendLine($@"					list = list.Next;");
				code.AppendLine($@"				}}");
				code.AppendLine($@"			}}");
				code.AppendLine($@"			else if (node is Branch branch)");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				foreach (Node child in branch.Children)");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					Stepper(child, step);");
				code.AppendLine($@"				}}");
				code.AppendLine($@"			}}");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		#endregion");
				code.AppendLine($@"");

				#endregion

				#region StepperBreak

				code.AppendLine($@"		#region StepperBreak");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Traverses this tree and performs a step on every value.</summary>");
				code.AppendLine($@"		/// <param name=""step"">The action to perform on every during traversal.</param>");
				code.AppendLine($@"		public StepStatus StepperBreak(Func<T, StepStatus> step)");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			if (step is null) throw new ArgumentNullException(nameof(step));");
				code.AppendLine($@"			return StepperBreak<SFunc<T, StepStatus>>(step);");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Traverses this tree and performs a step on every value.</summary>");
				code.AppendLine($@"		/// <typeparam name=""Step"">The action to perform on every during traversal.</typeparam>");
				code.AppendLine($@"		/// <param name=""step"">The action to perform on every during traversal.</param>");
				code.AppendLine($@"		public StepStatus StepperBreak<Step>(Step step = default)");
				code.AppendLine($@"			where Step : struct, IFunc<T, StepStatus> =>");
				code.AppendLine($@"			StepperBreak(_top, step);");
				code.AppendLine($@"");
				code.AppendLine($@"		internal StepStatus StepperBreak<Step>(Node node, Step step)");
				code.AppendLine($@"			where Step : struct, IFunc<T, StepStatus>");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			if (node is Leaf leaf)");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				Leaf.Node list = leaf.Head;");
				code.AppendLine($@"				while (list is not null)");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					if (step.Invoke(list.Value) is Break)");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						return Break;");
				code.AppendLine($@"					}}");
				code.AppendLine($@"					list = list.Next;");
				code.AppendLine($@"				}}");
				code.AppendLine($@"			}}");
				code.AppendLine($@"			else if (node is Branch branch)");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				foreach (Node child in branch.Children)");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					if (StepperBreak(child, step) is Break)");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						return Break;");
				code.AppendLine($@"					}}");
				code.AppendLine($@"				}}");
				code.AppendLine($@"			}}");
				code.AppendLine($@"			return Continue;");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		#endregion");
				code.AppendLine($@"");

				#endregion

				#region Stepper (space)

				code.AppendLine($@"		#region Stepper (space)");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Traverses this tree and performs a step on every value.</summary>");
				code.AppendLine($@"		/// <param name=""step"">The action to perform on every during traversal.</param>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		/// <param name=""min{j}"">The minimum bound on the {j}D axis.</param>");
					code.AppendLine($@"		/// <param name=""max{j}"">The maximum bound on the {j}D axis.</param>");
				}
				code.AppendLine($@"		public void Stepper(Action<T> step,");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			Axis{j} min{j}, Axis{j} max{j}{(j == i ? ")" : ",")}");
				}
				code.AppendLine($@"		{{");
				code.AppendLine($@"			if (step is null) throw new ArgumentNullException(nameof(step));");
				code.AppendLine($@"			Stepper<SAction<T>>(_top, new(");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"				min{j}, max{j}{(j == i ? ")," : ",")}");
				}
				code.AppendLine($@"				step);");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Traverses this tree and performs a step on every value.</summary>");
				code.AppendLine($@"		/// <param name=""step"">The action to perform on every during traversal.</param>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		/// <param name=""min{j}"">The minimum bound on the {j}D axis.</param>");
					code.AppendLine($@"		/// <param name=""max{j}"">The maximum bound on the {j}D axis.</param>");
				}
				code.AppendLine($@"		public void Stepper(Action<T> step,");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			Towel.DataStructures.Omnitree.Bound<Axis{j}> min{j}, Towel.DataStructures.Omnitree.Bound<Axis{j}> max{j}{(j == i ? ")" : ",")}");
				}
				code.AppendLine($@"		{{");
				code.AppendLine($@"			if (step is null) throw new ArgumentNullException(nameof(step));");
				code.AppendLine($@"			Stepper<SAction<T>>(_top, new(");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"				min{j}, max{j}{(j == i ? ")," : ",")}");
				}
				code.AppendLine($@"				step);");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Traverses this tree and performs a step on every value.</summary>");
				code.AppendLine($@"		/// <typeparam name=""Step"">The action to perform on every during traversal.</typeparam>");
				code.AppendLine($@"		/// <param name=""step"">The action to perform on every during traversal.</param>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		/// <param name=""min{j}"">The minimum bound on the {j}D axis.</param>");
					code.AppendLine($@"		/// <param name=""max{j}"">The maximum bound on the {j}D axis.</param>");
				}
				code.AppendLine($@"		public void Stepper<Step>(");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			Axis{j} min{j}, Axis{j} max{j},");
				}
				code.AppendLine($@"			Step step = default)");
				code.AppendLine($@"			where Step : struct, IAction<T>");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			Stepper<Step>(_top, new(");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"				min{j}, max{j}{(j == i ? ")," : ",")}");
				}
				code.AppendLine($@"				step);");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Traverses this tree and performs a step on every value.</summary>");
				code.AppendLine($@"		/// <typeparam name=""Step"">The action to perform on every during traversal.</typeparam>");
				code.AppendLine($@"		/// <param name=""step"">The action to perform on every during traversal.</param>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		/// <param name=""min{j}"">The minimum bound on the {j}D axis.</param>");
					code.AppendLine($@"		/// <param name=""max{j}"">The maximum bound on the {j}D axis.</param>");
				}
				code.AppendLine($@"		public void Stepper<Step>(");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			Towel.DataStructures.Omnitree.Bound<Axis{j}> min{j}, Towel.DataStructures.Omnitree.Bound<Axis{j}> max{j},");
				}
				code.AppendLine($@"			Step step = default)");
				code.AppendLine($@"			where Step : struct, IAction<T>");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			Stepper<Step>(_top, new(");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"				min{j}, max{j}{(j == i ? ")," : ",")}");
				}
				code.AppendLine($@"				step);");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		internal void Stepper<Step>(Node node, Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> bounds, Step step)");
				code.AppendLine($@"			where Step : struct, IAction<T>");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			if (node is Leaf leaf)");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				for (Leaf.Node list = leaf.Head; list is not null; list = list.Next)");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					if (Omnitree.ContainsCheck(bounds, FullLocate(list.Value), {Join(1..I, n => $"_compare{n}", ", ")}))");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						step.Invoke(list.Value);");
				code.AppendLine($@"					}}");
				code.AppendLine($@"				}}");
				code.AppendLine($@"			}}");
				code.AppendLine($@"			if (node is Branch branch)");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				foreach (Node child in branch.Children)");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					if (Omnitree.ContainsCheck(bounds, child.Bounds, {Join(1..I, n => $"_compare{n}", ", ")}))");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						Stepper(child, step);");
				code.AppendLine($@"					}}");
				code.AppendLine($@"					else if (Omnitree.OverlapCheck(child.Bounds, bounds, {Join(1..I, n => $"_compare{n}", ", ")}))");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						Stepper(child, bounds, step);");
				code.AppendLine($@"					}}");
				code.AppendLine($@"				}}");
				code.AppendLine($@"			}}");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		#endregion");
				code.AppendLine($@"");

				#endregion

				#region StepperBreak (space)

				code.AppendLine($@"		#region StepperBreak (space)");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Traverses this tree and performs a step on every value.</summary>");
				code.AppendLine($@"		/// <param name=""step"">The action to perform on every during traversal.</param>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		/// <param name=""min{j}"">The minimum bound on the {j}D axis.</param>");
					code.AppendLine($@"		/// <param name=""max{j}"">The maximum bound on the {j}D axis.</param>");
				}
				code.AppendLine($@"		public StepStatus StepperBreak(");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			Axis{j} min{j}, Axis{j} max{j},");
				}
				code.AppendLine($@"			Func<T, StepStatus> step)");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			if (step is null) throw new ArgumentNullException(nameof(step));");
				code.AppendLine($@"			return StepperBreak<SFunc<T, StepStatus>>(_top, new(");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"				min{j}, max{j}{(j == i ? ")," : ",")}");
				}
				code.AppendLine($@"				step);");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Traverses this tree and performs a step on every value.</summary>");
				code.AppendLine($@"		/// <param name=""step"">The action to perform on every during traversal.</param>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		/// <param name=""min{j}"">The minimum bound on the {j}D axis.</param>");
					code.AppendLine($@"		/// <param name=""max{j}"">The maximum bound on the {j}D axis.</param>");
				}
				code.AppendLine($@"		public StepStatus StepperBreak(");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			Towel.DataStructures.Omnitree.Bound<Axis{j}> min{j}, Towel.DataStructures.Omnitree.Bound<Axis{j}> max{j},");
				}
				code.AppendLine($@"			Func<T, StepStatus> step)");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			if (step is null) throw new ArgumentNullException(nameof(step));");
				code.AppendLine($@"			return StepperBreak<SFunc<T, StepStatus>>(_top, new(");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"				min{j}, max{j}{(j == i ? ")," : ",")}");
				}
				code.AppendLine($@"				step);");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Traverses this tree and performs a step on every value.</summary>");
				code.AppendLine($@"		/// <typeparam name=""Step"">The action to perform on every during traversal.</typeparam>");
				code.AppendLine($@"		/// <param name=""step"">The action to perform on every during traversal.</param>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		/// <param name=""min{j}"">The minimum bound on the {j}D axis.</param>");
					code.AppendLine($@"		/// <param name=""max{j}"">The maximum bound on the {j}D axis.</param>");
				}
				code.AppendLine($@"		public StepStatus StepperBreak<Step>(");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			Axis{j} min{j}, Axis{j} max{j},");
				}
				code.AppendLine($@"			Step step = default)");
				code.AppendLine($@"			where Step : struct, IFunc<T, StepStatus>");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			return StepperBreak<Step>(_top, new(");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"				min{j}, max{j}{(j == i ? ")," : ",")}");
				}
				code.AppendLine($@"				step);");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <summary>Traverses this tree and performs a step on every value.</summary>");
				code.AppendLine($@"		/// <typeparam name=""Step"">The action to perform on every during traversal.</typeparam>");
				code.AppendLine($@"		/// <param name=""step"">The action to perform on every during traversal.</param>");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"		/// <param name=""min{j}"">The minimum bound on the {j}D axis.</param>");
					code.AppendLine($@"		/// <param name=""max{j}"">The maximum bound on the {j}D axis.</param>");
				}
				code.AppendLine($@"		public StepStatus StepperBreak<Step>(");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"			Towel.DataStructures.Omnitree.Bound<Axis{j}> min{j}, Towel.DataStructures.Omnitree.Bound<Axis{j}> max{j},");
				}
				code.AppendLine($@"			Step step = default)");
				code.AppendLine($@"			where Step : struct, IFunc<T, StepStatus>");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			return StepperBreak<Step>(_top, new(");
				for (int j = 1; j <= i; j++)
				{
					code.AppendLine($@"				min{j}, max{j}{(j == i ? ")," : ",")}");
				}
				code.AppendLine($@"				step);");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		internal StepStatus StepperBreak<Step>(Node node, Omnitree.Bounds<{Join(1..I, n => $"Axis{n}", ", ")}> bounds, Step step)");
				code.AppendLine($@"			where Step : struct, IFunc<T, StepStatus>");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			if (node is Leaf leaf)");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				for (Leaf.Node list = leaf.Head; list is not null; list = list.Next)");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					if (Omnitree.ContainsCheck(bounds, FullLocate(list.Value), {Join(1..I, n => $"_compare{n}", ", ")}))");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						if (step.Invoke(list.Value) is Break)");
				code.AppendLine($@"						{{");
				code.AppendLine($@"							return Break;");
				code.AppendLine($@"						}}");
				code.AppendLine($@"					}}");
				code.AppendLine($@"				}}");
				code.AppendLine($@"			}}");
				code.AppendLine($@"			if (node is Branch branch)");
				code.AppendLine($@"			{{");
				code.AppendLine($@"				foreach (Node child in branch.Children)");
				code.AppendLine($@"				{{");
				code.AppendLine($@"					if (Omnitree.ContainsCheck(bounds, child.Bounds, {Join(1..I, n => $"_compare{n}", ", ")}))");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						if (StepperBreak(child, step) is Break)");
				code.AppendLine($@"						{{");
				code.AppendLine($@"							return Break;");
				code.AppendLine($@"						}}");
				code.AppendLine($@"					}}");
				code.AppendLine($@"					else if (Omnitree.OverlapCheck(child.Bounds, bounds, {Join(1..I, n => $"_compare{n}", ", ")}))");
				code.AppendLine($@"					{{");
				code.AppendLine($@"						if (StepperBreak(child, bounds, step) is Break)");
				code.AppendLine($@"						{{");
				code.AppendLine($@"							return Break;");
				code.AppendLine($@"						}}");
				code.AppendLine($@"					}}");
				code.AppendLine($@"				}}");
				code.AppendLine($@"			}}");
				code.AppendLine($@"			return Continue;");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		#endregion");
				code.AppendLine($@"");

				#endregion

				#region Stepper

				///// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
				///// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
				///// <param name="axis1">The axis of the removal along the  1D axis.</param>
				///// <param name="axis2">The axis of the removal along the  2D axis.</param>
				///// <param name="axis3">The axis of the removal along the  3D axis.</param>
				//public void Stepper(Action<T> step, Axis1 axis1, Axis2 axis2, Axis3 axis3) =>
				//	Stepper(step, _top, new Omnitree.Vector<Axis1, Axis2, Axis3>(axis1, axis2, axis3));

				//internal void Stepper(Action<T> step, Node node, Omnitree.Vector<Axis1, Axis2, Axis3> vector)
				//{
				//	Node current = node;
				//	while (current is not null)
				//	{
				//		if (current is Leaf)
				//		{
				//			for (Leaf.Node leaf_node = (current as Leaf).Head; leaf_node is not null; leaf_node = leaf_node.Next)
				//				if (EqualsCheck(vector, LocateVector(leaf_node.Value)))
				//					step(leaf_node.Value);
				//			break;
				//		}
				//		else
				//		{
				//			Branch branch = current as Branch;
				//			int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
				//			current = branch[child_index];
				//		}
				//	}
				//}

				///// <summary>Performs and specialized traversal of the structure and performs a delegate on every node within the provided dimensions.</summary>
				///// <param name="step">The delegate to perform on all items in the tree within the given bounds.</param>
				///// <param name="axis1">The axis of the removal along the  1D axis.</param>
				///// <param name="axis2">The axis of the removal along the  2D axis.</param>
				///// <param name="axis3">The axis of the removal along the  3D axis.</param>
				//public StepStatus Stepper(Func<T, StepStatus> step, Axis1 axis1, Axis2 axis2, Axis3 axis3) =>
				//	Stepper(step, _top, new Omnitree.Vector<Axis1, Axis2, Axis3>(axis1, axis2, axis3));

				//internal StepStatus Stepper(Func<T, StepStatus> step, Node node, Omnitree.Vector<Axis1, Axis2, Axis3> vector)
				//{
				//	Node current = node;
				//	while (current is not null)
				//	{
				//		if (current is Leaf)
				//		{
				//			for (Leaf.Node list = (current as Leaf).Head; list is not null; list = list.Next)
				//			{
				//				StepStatus status = StepStatus.Continue;
				//				if (EqualsCheck(vector, LocateVector(list.Value)) &&
				//					(status = step(list.Value)) != StepStatus.Continue)
				//					return status;
				//			}
				//		}
				//		else
				//		{
				//			Branch branch = current as Branch;
				//			int child_index = DetermineChildIndex(branch.PointOfDivision, vector);
				//			current = branch[child_index];
				//		}
				//	}
				//	return StepStatus.Continue;
				//}

				//System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();

				//public System.Collections.Generic.IEnumerator<T> GetEnumerator()
				//{
				//	// Note: this can be optimized.
				//	IList<T> list = new ListLinked<T>();
				//	Stepper(x => list.Add(x));
				//	return list.GetEnumerator();
				//}

				//#endregion

				#endregion

				#region GetEnumerator

				code.AppendLine($@"		#region GetEnumerator");
				code.AppendLine($@"");
				code.AppendLine($@"		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <inheritdoc />");
				code.AppendLine($@"		public System.Collections.Generic.IEnumerator<T> GetEnumerator()");
				code.AppendLine($@"		{{");
				#warning TODO: optimize
				code.AppendLine($@"			// TODO: optimize");
				code.AppendLine($@"			return ((System.Collections.Generic.IEnumerable<T>)ToArray()).GetEnumerator();");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		#endregion");
				code.AppendLine($@"");

				#endregion

				#region ToArray

				code.AppendLine($@"		#region ToArray");
				code.AppendLine($@"");
				code.AppendLine($@"		/// <inheritdoc />");
				code.AppendLine($@"		public T[] ToArray()");
				code.AppendLine($@"		{{");
				code.AppendLine($@"			T[] array = new T[_top.Count];");
				code.AppendLine($@"			int i = 0;");
				#warning TODO: optimize
				code.AppendLine($@"			// TODO: optimize");
				code.AppendLine($@"			Stepper<SAction<T>>(new Action<T>(x => array[i++] = x));");
				code.AppendLine($@"			return array;");
				code.AppendLine($@"		}}");
				code.AppendLine($@"");
				code.AppendLine($@"		#endregion");
				code.AppendLine($@"");

				#endregion

				code.AppendLine($@"		#endregion");
				code.AppendLine($@"");

				#endregion

				code.AppendLine($@"	}}");

				#endregion

				code.AppendLine($@"");
				code.AppendLine($@"	#endregion");
				code.AppendLine($@"");
				code.AppendLine($@"	#endregion");
				if (i < dimensions)
				{
					code.AppendLine($@"");
				}
			}
			code.AppendLine($@"}}");
			return code.ToString();
		}
	}
}